

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>Privilege Escalation &#8212; The Atomic Playbook</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" integrity="sha384-KA6wR/X5RY4zFAHpv/CnoG2UW1uogYfdnP67Uv7eULvTveboZJg0qUpmJZb5VqzN" crossorigin="anonymous">
    <link href="../_static/css/index.css" rel="stylesheet">
    <link rel="stylesheet" href="../_static/sphinx-book-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/jupyter-sphinx.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/mystnb.js"></script>
    <script src="../_static/sphinx-book-theme.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="T1548.002 - Abuse Elevation Control Mechanism: Bypass User Access Control" href="privilege-escalation/T1548.002.html" />
    <link rel="prev" title="T1053.003 - Scheduled Task/Job: Cron" href="persistence/T1053.003.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="docsearch:language" content="en">



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/logo.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">The Atomic Playbook</h1>
  
</a>
</div>

<form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>

<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro.html">
   Welcome to the Atomic Playbook
  </a>
 </li>
</ul>
<ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="initial-access.html">
   Initial Access
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="execution.html">
   Execution
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="persistence.html">
   Persistence
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Privilege Escalation
  </a>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1548.002.html">
     T1548.002 - Abuse Elevation Control Mechanism: Bypass User Access Control
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.008.html">
     T1546.008 - Event Triggered Execution: Accessibility Features
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.011.html">
     T1546.011 - Event Triggered Execution: Application Shimming
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1055.009.html">
     T1055.009 - Proc Memory
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.013.html">
     T1546.013 - Event Triggered Execution: PowerShell Profile
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1547.html">
     T1547 - Boot or Logon Autostart Execution
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1547.009.html">
     T1547.009 - Boot or Logon Autostart Execution: Shortcut Modification
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1055.012.html">
     T1055.012 - Process Injection: Process Hollowing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1543.004.html">
     T1543.004 - Create or Modify System Process: Launch Daemon
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1547.010.html">
     T1547.010 - Port Monitors
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1574.012.html">
     T1574.012 - Hijack Execution Flow: COR_PROFILER
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1548.004.html">
     T1548.004 - Elevated Execution with Prompt
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1543.html">
     T1543 - Create or Modify System Process
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1037.html">
     T1037 - Boot or Logon Initialization Scripts
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1574.009.html">
     T1574.009 - Hijack Execution Flow: Path Interception by Unquoted Path
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.015.html">
     T1546.015 - Component Object Model Hijacking
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1543.002.html">
     T1543.002 - Create or Modify System Process: Systemd Service
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1574.010.html">
     T1574.010 - Hijack Execution Flow: Services File Permissions Weakness
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1055.014.html">
     T1055.014 - VDSO Hijacking
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1547.008.html">
     T1547.008 - LSASS Driver
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.html">
     T1546 - Event Triggered Execution
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.012.html">
     T1546.012 - Event Triggered Execution: Image File Execution Options Injection
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1547.011.html">
     T1547.011 - Boot or Logon Autostart Execution: Plist Modification
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1548.001.html">
     T1548.001 - Abuse Elevation Control Mechanism: Setuid and Setgid
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1053.html">
     T1053 - Scheduled Task/Job
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1055.013.html">
     T1055.013 - Process Doppelg√§nging
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.009.html">
     T1546.009 - AppCert DLLs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1055.011.html">
     T1055.011 - Extra Window Memory Injection
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1134.html">
     T1134 - Access Token Manipulation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1548.003.html">
     T1548.003 - Abuse Elevation Control Mechanism: Sudo and Sudo Caching
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1055.008.html">
     T1055.008 - Ptrace System Calls
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.010.html">
     T1546.010 - Event Triggered Execution: AppInit DLLs
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.014.html">
     T1546.014 - Event Triggered Execution: Emond
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1034.html">
     T1034 - Path Interception
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1574.008.html">
     T1574.008 - Path Interception by Search Order Hijacking
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1574.011.html">
     T1574.011 - Hijack Execution Flow: Services Registry Permissions Weakness
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1068.html">
     T1068 - Exploitation for Privilege Escalation
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1055.html">
     T1055 - Process Injection
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1484.html">
     T1484 - Group Policy Modification
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1543.003.html">
     T1543.003 - Create or Modify System Process: Windows Service
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1543.001.html">
     T1543.001 - Create or Modify System Process: Launch Agent
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1055.002.html">
     T1055.002 - Portable Executable Injection
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1574.006.html">
     T1574.006 - Hijack Execution Flow: LD_PRELOAD
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1134.004.html">
     T1134.004 - Access Token Manipulation: Parent PID Spoofing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1037.003.html">
     T1037.003 - Network Logon Script
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.003.html">
     T1546.003 - Event Triggered Execution: Windows Management Instrumentation Event Subscription
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1078.003.html">
     T1078.003 - Local Accounts
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1053.004.html">
     T1053.004 - Scheduled Task/Job: Launchd
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1078.001.html">
     T1078.001 - Valid Accounts: Default Accounts
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.001.html">
     T1546.001 - Event Triggered Execution: Change Default File Association
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1037.001.html">
     T1037.001 - Boot or Logon Initialization Scripts: Logon Script (Windows)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1547.002.html">
     T1547.002 - Authentication Package
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1574.004.html">
     T1574.004 - Dylib Hijacking
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1547.006.html">
     T1547.006 - Boot or Logon Autostart Execution: Kernel Modules and Extensions
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1037.005.html">
     T1037.005 - Boot or Logon Initialization Scripts: Startup Items
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1548.html">
     T1548 - Abuse Elevation Control Mechanism
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1134.002.html">
     T1134.002 - Create Process with Token
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1055.004.html">
     T1055.004 - Process Injection: Asynchronous Procedure Call
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1053.002.html">
     T1053.002 - Scheduled Task/Job: At (Windows)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.005.html">
     T1546.005 - Event Triggered Execution: Trap
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.007.html">
     T1546.007 - Event Triggered Execution: Netsh Helper DLL
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1574.002.html">
     T1574.002 - Hijack Execution Flow: DLL Side-Loading
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1547.004.html">
     T1547.004 - Boot or Logon Autostart Execution: Winlogon Helper DLL
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1055.001.html">
     T1055.001 - Dynamic-link Library Injection
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1574.005.html">
     T1574.005 - Executable Installer File Permissions Weakness
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1547.003.html">
     T1547.003 - Time Providers
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1547.001.html">
     T1547.001 - Boot or Logon Autostart Execution: Registry Run Keys / Startup Folder
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1037.002.html">
     T1037.002 - Boot or Logon Initialization Scripts: Logon Script (Mac)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1055.003.html">
     T1055.003 - Thread Execution Hijacking
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1574.007.html">
     T1574.007 - Path Interception by PATH Environment Variable
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1134.005.html">
     T1134.005 - SID-History Injection
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1053.005.html">
     T1053.005 - Scheduled Task/Job: Scheduled Task
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1078.002.html">
     T1078.002 - Domain Accounts
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.002.html">
     T1546.002 - Event Triggered Execution: Screensaver
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1053.001.html">
     T1053.001 - Scheduled Task/Job: At (Linux)
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.006.html">
     T1546.006 - LC_LOAD_DYLIB Addition
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1547.005.html">
     T1547.005 - Boot or Logon Autostart Execution: Security Support Provider
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1134.001.html">
     T1134.001 - Token Impersonation/Theft
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1078.html">
     T1078 - Valid Accounts
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1134.003.html">
     T1134.003 - Make and Impersonate Token
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1055.005.html">
     T1055.005 - Thread Local Storage
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1574.001.html">
     T1574.001 - Hijack Execution Flow: DLL Search Order Hijacking
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1547.007.html">
     T1547.007 - Boot or Logon Autostart Execution: Re-opened Applications
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1574.html">
     T1574 - Hijack Execution Flow
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1037.004.html">
     T1037.004 - Boot or Logon Initialization Scripts: Rc.common
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1546.004.html">
     T1546.004 - Event Triggered Execution: .bash_profile and .bashrc
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1078.004.html">
     T1078.004 - Cloud Accounts
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="privilege-escalation/T1053.003.html">
     T1053.003 - Scheduled Task/Job: Cron
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="defense-evasion.html">
   Defense Evasion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="credential-access.html">
   Credential Access
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="discovery.html">
   Discovery
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lateral-movement.html">
   Lateral Movement
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="collection.html">
   Collection
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="command-and-control.html">
   Command and Control
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="exfiltration.html">
   Exfiltration
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="impact.html">
   Impact
  </a>
 </li>
</ul>

</nav>

 <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        <div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    
    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/tactics/privilege-escalation.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
    
</div>
        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#techniques">
   Techniques
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unquoted-paths">
     Unquoted Paths
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#path-environment-variable-misconfiguration">
     PATH Environment Variable Misconfiguration
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#search-order-hijacking">
     Search Order Hijacking
    </a>
   </li>
  </ul>
 </li>
</ul>

        </nav>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="privilege-escalation">
<h1>Privilege Escalation<a class="headerlink" href="#privilege-escalation" title="Permalink to this headline">¬∂</a></h1>
<p>The adversary is trying to gain higher-level permissions.</p>
<p>Privilege Escalation consists of techniques that adversaries use to gain higher-level permissions on a system or network. Adversaries can often enter and explore a network with unprivileged access but require elevated permissions to follow through on their objectives. Common approaches are to take advantage of system weaknesses, misconfigurations, and vulnerabilities. Examples of elevated access include:
‚Ä¢	SYSTEM/root level
‚Ä¢	local administrator
‚Ä¢	user account with admin-like access
‚Ä¢	user accounts with access to specific system or perform specific function
These techniques often overlap with Persistence techniques, as OS features that let an adversary persist can execute in an elevated context.</p>
<div class="section" id="techniques">
<h2>Techniques<a class="headerlink" href="#techniques" title="Permalink to this headline">¬∂</a></h2>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>ID</p></th>
<th class="text-align:center head"><p>Name</p></th>
<th class="text-align:center head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>T1574.012</p></td>
<td class="text-align:center"><p>COR_PROFILER</p></td>
<td class="text-align:center"><p>Adversaries may leverage the COR_PROFILER environment variable to hijack the execution flow of programs that load the .NET CLR. The COR_PROFILER is a .NET Framework feature which allows developers to specify an unmanaged (or external of .NET) profiling DLL to be loaded into each .NET process that loads the Common Language Runtime (CLR). These profiliers are designed to monitor, troubleshoot, and debug managed code executed by the .NET CLR.(Citation: Microsoft Profiling Mar 2017)(Citation: Microsoft COR_PROFILER Feb 2013)</p></td>
</tr>
</tbody>
</table>
<p>The COR_PROFILER environment variable can be set at various scopes (system, user, or process) resulting in different levels of influence. System and user-wide environment variable scopes are specified in the Registry, where a <a class="reference external" href="https://attack.mitre.org/techniques/T1559/001">Component Object Model</a> (COM) object can be registered as a profiler DLL. A process scope COR_PROFILER can also be created in-memory without modifying the Registry. Starting with .NET Framework 4, the profiling DLL does not need to be registered as long as the location of the DLL is specified in the COR_PROFILER_PATH environment variable.(Citation: Microsoft COR_PROFILER Feb 2013)</p>
<p>Adversaries may abuse COR_PROFILER to establish persistence that executes a malicious DLL in the context of all .NET processes every time the CLR is invoked. The COR_PROFILER can also be used to elevate privileges (ex: <a class="reference external" href="https://attack.mitre.org/techniques/T1548/002">Bypass User Access Control</a>) if the victim .NET process executes at a higher permission level, as well as to hook and <a class="reference external" href="https://attack.mitre.org/techniques/T1562">Impair Defenses</a> provided by .NET processes.(Citation: RedCanary Mockingbird May 2020)(Citation: Red Canary COR_PROFILER May 2020)(Citation: Almond COR_PROFILER Apr 2019)(Citation: GitHub OmerYa Invisi-Shell)(Citation: subTee .NET Profilers May 2017)
T1574.004 | Dylib Hijacking | Adversaries may execute their own malicious payloads by hijacking ambiguous paths  used to load libraries. Adversaries may plant trojan dynamic libraries, in a directory that will be searched by the operating system before the legitimate library specified by the victim program, so that their malicious library will be loaded into the victim program instead.  MacOS and OS X use a common method to look for required dynamic libraries (dylib) to load into a program based on search paths.</p>
<p>A common method is to see what dylibs an application uses, then plant a malicious version with the same name higher up in the search path. This typically results in the dylib being in the same folder as the application itself. (Citation: Writing Bad Malware for OSX) (Citation: Malware Persistence on OS X)</p>
<p>If the program is configured to run at a higher privilege level than the current user, then when the dylib is loaded into the application, the dylib will also run at that elevated level.
T1546.015 | Component Object Model Hijacking | Adversaries may establish persistence by executing malicious content triggered by hijacked references to Component Object Model (COM) objects. COM is a system within Windows to enable interaction between software components through the operating system.(Citation: Microsoft Component Object Model)  References to various COM objects are stored in the Registry.</p>
<p>Adversaries can use the COM system to insert malicious code that can be executed in place of legitimate software through hijacking the COM references and relationships as a means for persistence. Hijacking a COM object requires a change in the Registry to replace a reference to a legitimate system component which may cause that component to not work when executed. When that system component is executed through normal system operation the adversary‚Äôs code will be executed instead.(Citation: GDATA COM Hijacking) An adversary is likely to hijack objects that are used frequently enough to maintain a consistent level of persistence, but are unlikely to break noticeable functionality within the system as to avoid system instability that could lead to detection.
T1078.004 | Cloud Accounts | Adversaries may obtain and abuse credentials of a cloud account as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion. Cloud accounts are those created and configured by an organization for use by users, remote support, services, or for administration of resources within a cloud service provider or SaaS application. In some cases, cloud accounts may be federated with traditional identity management system, such as Window Active Directory.(Citation: AWS Identity Federation)(Citation: Google Federating GC)(Citation: Microsoft Deploying AD Federation)</p>
<p>Compromised credentials for cloud accounts can be used to harvest sensitive data from online storage accounts and databases. Access to cloud accounts can also be abused to gain Initial Access to a network by abusing a <a class="reference external" href="https://attack.mitre.org/techniques/T1199">Trusted Relationship</a>. Similar to <a class="reference external" href="https://attack.mitre.org/techniques/T1078/002">Domain Accounts</a>, compromise of federated cloud accounts may allow adversaries to more easily move laterally within an environment.
T1078.003 | Local Accounts | Adversaries may obtain and abuse credentials of a local account as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion. Local accounts are those configured by an organization for use by users, remote support, services, or for administration on a single system or service.</p>
<p>Local Accounts may also be abused to elevate privileges and harvest credentials through <a class="reference external" href="https://attack.mitre.org/techniques/T1003">OS Credential Dumping</a>. Password reuse may allow the abuse of local accounts across a set of machines on a network for the purposes of Privilege Escalation and Lateral Movement.
T1078.002 | Domain Accounts | Adversaries may obtain and abuse credentials of a domain account as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion. (Citation: TechNet Credential Theft) Domain accounts are those managed by Active Directory Domain Services where access and permissions are configured across systems and services that are part of that domain. Domain accounts can cover users, administrators, and services.(Citation: Microsoft AD Accounts)</p>
<p>Adversaries may compromise domain accounts, some with a high level of privileges, through various means such as <a class="reference external" href="https://attack.mitre.org/techniques/T1003">OS Credential Dumping</a> or password reuse, allowing access to privileged resources of the domain.
T1078.001 | Default Accounts | Adversaries may obtain and abuse credentials of a default account as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion. Default accounts are those that are built-into an OS, such as the Guest or Administrator accounts on Windows systems or default factory/provider set accounts on other types of systems, software, or devices.(Citation: Microsoft Local Accounts Feb 2019)</p>
<p>Default accounts are not limited to client machines, rather also include accounts that are preset for equipment such as network devices and computer applications whether they are internal, open source, or commercial. Appliances that come preset with a username and password combination pose a serious threat to organizations that do not change it post installation, as they are easy targets for an adversary. Similarly, adversaries may also utilize publicly disclosed or stolen <a class="reference external" href="https://attack.mitre.org/techniques/T1552/004">Private Keys</a> or credential materials to legitimately connect to remote environments via <a class="reference external" href="https://attack.mitre.org/techniques/T1021">Remote Services</a>.(Citation: Metasploit SSH Module)
T1574.006 | LD_PRELOAD | Adversaries may execute their own malicious payloads by hijacking the dynamic linker used to load libraries. The dynamic linker is used to load shared library dependencies needed by an executing program. The dynamic linker will typically check provided absolute paths and common directories for these dependencies, but can be overridden by shared objects specified by LD_PRELOAD to be loaded before all others.(Citation: Man LD.SO)(Citation: TLDP Shared Libraries)</p>
<p>Adversaries may set LD_PRELOAD to point to malicious libraries that match the name of legitimate libraries which are requested by a victim program, causing the operating system to load the adversary‚Äôs malicious code upon execution of the victim program. LD_PRELOAD can be set via the environment variable or <code>/etc/ld.so.preload</code> file.(Citation: Man LD.SO)(Citation: TLDP Shared Libraries) Libraries specified by LD_PRELOAD with be loaded and mapped into memory by <code>dlopen()</code> and <code>mmap()</code> respectively.(Citation: Code Injection on Linux and macOS) (Citation: Uninformed Needle) (Citation: Phrack halfdead 1997)</p>
<p>LD_PRELOAD hijacking may grant access to the victim process‚Äôs memory, system/network resources, and possibly elevated privileges. Execution via LD_PRELOAD hijacking may also evade detection from security products since the execution is masked under a legitimate process.
T1574.002 | DLL Side-Loading | Adversaries may execute their own malicious payloads by hijacking the library manifest used to load DLLs. Adversaries may take advantage of vague references in the library manifest of a program by replacing a legitimate library with a malicious one, causing the operating system to load their malicious library when it is called for by the victim program.</p>
<p>Programs may specify DLLs that are loaded at runtime. Programs that improperly or vaguely specify a required DLL may be open to a vulnerability in which an unintended DLL is loaded. Side-loading vulnerabilities specifically occur when Windows Side-by-Side (WinSxS) manifests (Citation: About Side by Side Assemblies) are not explicit enough about characteristics of the DLL to be loaded. Adversaries may take advantage of a legitimate program that is vulnerable by replacing the legitimate DLL with a malicious one.  (Citation: FireEye DLL Side-Loading)</p>
<p>Adversaries likely use this technique as a means of masking actions they perform under a legitimate, trusted system or software process.
T1574.001 | DLL Search Order Hijacking | Adversaries may execute their own malicious payloads by hijacking the search order used to load DLLs. Windows systems use a common method to look for required DLLs to load into a program. (Citation: Microsoft Dynamic Link Library Search Order) Hijacking DLL loads may be for the purpose of establishing persistence as well as elevating privileges and/or evading restrictions on file execution.</p>
<p>There are many ways an adversary can hijack DLL loads. Adversaries may plant trojan dynamic-link library files (DLLs) in a directory that will be searched before the location of a legitimate library that will be requested by a program, causing Windows to load their malicious library when it is called for by the victim program. Adversaries may also perform DLL preloading, also called binary planting attacks, (Citation: OWASP Binary Planting) by placing a malicious DLL with the same name as an ambiguously specified DLL in a location that Windows searches before the legitimate DLL. Often this location is the current working directory of the program. Remote DLL preloading attacks occur when a program sets its current directory to a remote location such as a Web share before loading a DLL. (Citation: Microsoft Security Advisory 2269637)</p>
<p>Adversaries may also directly modify the way a program loads DLLs by replacing an existing DLL or modifying a .manifest or .local redirection file, directory, or junction to cause the program to load a different DLL. (Citation: Microsoft Dynamic-Link Library Redirection) (Citation: Microsoft Manifests) (Citation: FireEye DLL Search Order Hijacking)</p>
<p>If a search order-vulnerable program is configured to run at a higher privilege level, then the adversary-controlled DLL that is loaded will also be executed at the higher level. In this case, the technique could be used for privilege escalation from user to administrator or SYSTEM or from administrator to SYSTEM, depending on the program.
Programs that fall victim to path hijacking may appear to behave normally because malicious DLLs may be configured to also load the legitimate DLLs they were meant to replace.
T1574.008 | Path Interception by Search Order Hijacking | Adversaries may execute their own malicious payloads by hijacking the search order used to load other programs. Because some programs do not call other programs using the full path, adversaries may place their own file in the directory where the calling program is located, causing the operating system to launch their malicious software at the request of the calling program.</p>
<p>Search order hijacking occurs when an adversary abuses the order in which Windows searches for programs that are not given a path. Unlike <a class="reference external" href="https://attack.mitre.org/techniques/T1574/001">DLL Search Order Hijacking</a>, the search order differs depending on the method that is used to execute the program. (Citation: Microsoft CreateProcess) (Citation: Windows NT Command Shell) (Citation: Microsoft WinExec) However, it is common for Windows to search in the directory of the initiating program before searching through the Windows system directory. An adversary who finds a program vulnerable to search order hijacking (i.e., a program that does not specify the path to an executable) may take advantage of this vulnerability by creating a program named after the improperly specified program and placing it within the initiating program‚Äôs directory.</p>
<p>For example, ‚Äúexample.exe‚Äù runs ‚Äúcmd.exe‚Äù with the command-line argument <code>net user</code>. An adversary may place a program called ‚Äúnet.exe‚Äù within the same directory as example.exe, ‚Äúnet.exe‚Äù will be run instead of the Windows system utility net. In addition, if an adversary places a program called ‚Äúnet.com‚Äù in the same directory as ‚Äúnet.exe‚Äù, then <code>cmd.exe /C net user</code> will execute ‚Äúnet.com‚Äù instead of ‚Äúnet.exe‚Äù due to the order of executable extensions defined under PATHEXT. (Citation: Microsoft Environment Property)</p>
<p>Search order hijacking is also a common practice for hijacking DLL loads and is covered in <a class="reference external" href="https://attack.mitre.org/techniques/T1574/001">DLL Search Order Hijacking</a>.
T1574.007 | Path Interception by PATH Environment Variable | Adversaries may execute their own malicious payloads by hijacking environment variables used to load libraries. Adversaries may place a program in an earlier entry in the list of directories stored in the PATH environment variable, which Windows will then execute when it searches sequentially through that PATH listing in search of the binary that was called from a script or the command line.</p>
<p>The PATH environment variable contains a list of directories. Certain methods of executing a program (namely using cmd.exe or the command-line) rely solely on the PATH environment variable to determine the locations that are searched for a program when the path for the program is not given. If any directories are listed in the PATH environment variable before the Windows directory, <code>%SystemRoot%\system32</code> (e.g., <code>C:\Windows\system32</code>), a program may be placed in the preceding directory that is named the same as a Windows program (such as cmd, PowerShell, or Python), which will be executed when that command is executed from a script or command-line.</p>
<p>For example, if <code>C:\example path</code> precedes </code>C:\Windows\system32</code> is in the PATH environment variable, a program that is named net.exe and placed in <code>C:\example path</code> will be called instead of the Windows system ‚Äúnet‚Äù when ‚Äúnet‚Äù is executed from the command-line.
T1574.009 | Path Interception by Unquoted Path | Adversaries may execute their own malicious payloads by hijacking vulnerable file path references. Adversaries can take advantage of paths that lack surrounding quotations by placing an executable in a higher level directory within the path, so that Windows will choose the adversary‚Äôs executable to launch.</p>
<p>Service paths (Citation: Microsoft CurrentControlSet Services) and shortcut paths may also be vulnerable to path interception if the path has one or more spaces and is not surrounded by quotation marks (e.g., <code>C:\unsafe path with space\program.exe</code> vs. <code>‚ÄùC:\safe path with space\program.exe‚Äù</code>). (Citation: Help eliminate unquoted path) (stored in Windows Registry keys) An adversary can place an executable in a higher level directory of the path, and Windows will resolve that executable instead of the intended executable. For example, if the path in a shortcut is <code>C:\program files\myapp.exe</code>, an adversary may create a program at <code>C:\program.exe</code> that will be run instead of the intended program. (Citation: Windows Unquoted Services) (Citation: Windows Privilege Escalation Guide)</p>
<p>This technique can be used for persistence if executables are called on a regular basis, as well as privilege escalation if intercepted executables are started by a higher privileged process.
T1574.011 | Services Registry Permissions Weakness | Adversaries may execute their own malicious payloads by hijacking the Registry entries used by services. Adversaries may use flaws in the permissions for registry to redirect from the originally specified executable to one that they control, in order to launch their own code at Service start.  Windows stores local service configuration information in the Registry under <code>HKLM\SYSTEM\CurrentControlSet\Services</code>. The information stored under a service‚Äôs Registry keys can be manipulated to modify a service‚Äôs execution parameters through tools such as the service controller, sc.exe,  <a class="reference external" href="https://attack.mitre.org/techniques/T1059/001">PowerShell</a>, or <a class="reference external" href="https://attack.mitre.org/software/S0075">Reg</a>. Access to Registry keys is controlled through Access Control Lists and permissions. (Citation: Registry Key Security)</p>
<p>If the permissions for users and groups are not properly set and allow access to the Registry keys for a service, then adversaries can change the service binPath/ImagePath to point to a different executable under their control. When the service starts or is restarted, then the adversary-controlled program will execute, allowing the adversary to gain persistence and/or privilege escalation to the account context the service is set to execute under (local/domain account, SYSTEM, LocalService, or NetworkService).</p>
<p>Adversaries may also alter Registry keys associated with service failure parameters (such as <code>FailureCommand</code>) that may be executed in an elevated context anytime the service fails or is intentionally corrupted.(Citation: Kansa Service related collectors)(Citation: Tweet Registry Perms Weakness)
T1574.005 | Executable Installer File Permissions Weakness | Adversaries may execute their own malicious payloads by hijacking the binaries used by an installer. These processes may automatically execute specific binaries as part of their functionality or to perform other actions. If the permissions on the file system directory containing a target binary, or permissions on the binary itself, are improperly set, then the target binary may be overwritten with another binary using user-level permissions and executed by the original process. If the original process and thread are running under a higher permissions level, then the replaced binary will also execute under higher-level permissions, which could include SYSTEM.</p>
<p>Another variation of this technique can be performed by taking advantage of a weakness that is common in executable, self-extracting installers. During the installation process, it is common for installers to use a subdirectory within the <code>%TEMP%</code> directory to unpack binaries such as DLLs, EXEs, or other payloads. When installers create subdirectories and files they often do not set appropriate permissions to restrict write access, which allows for execution of untrusted code placed in the subdirectories or overwriting of binaries used in the installation process. This behavior is related to and may take advantage of <a class="reference external" href="https://attack.mitre.org/techniques/T1574/001">DLL Search Order Hijacking</a>.</p>
<p>Adversaries may use this technique to replace legitimate binaries with malicious ones as a means of executing code at a higher permissions level. Some installers may also require elevated privileges that will result in privilege escalation when executing adversary controlled code. This behavior is related to <a class="reference external" href="https://attack.mitre.org/techniques/T1548/002">Bypass User Access Control</a>. Several examples of this weakness in existing common installers have been reported to software vendors.(Citation: mozilla_sec_adv_2012)  (Citation: Executable Installers are Vulnerable) If the executing process is set to run at a specific time or during a certain event (e.g., system bootup) then this technique can also be used for persistence.
T1574.010 | Services File Permissions Weakness | Adversaries may execute their own malicious payloads by hijacking the binaries used by services. Adversaries may use flaws in the permissions of Windows services to replace the binary that is executed upon service start. These service processes may automatically execute specific binaries as part of their functionality or to perform other actions. If the permissions on the file system directory containing a target binary, or permissions on the binary itself are improperly set, then the target binary may be overwritten with another binary using user-level permissions and executed by the original process. If the original process and thread are running under a higher permissions level, then the replaced binary will also execute under higher-level permissions, which could include SYSTEM.</p>
<p>Adversaries may use this technique to replace legitimate binaries with malicious ones as a means of executing code at a higher permissions level. If the executing process is set to run at a specific time or during a certain event (e.g., system bootup) then this technique can also be used for persistence.
T1574 | Hijack Execution Flow | Adversaries may execute their own malicious payloads by hijacking the way operating systems run programs. Hijacking execution flow can be for the purposes of persistence, since this hijacked execution may reoccur over time. Adversaries may also use these mechanisms to elevate privileges or evade defenses, such as application control or other restrictions on execution.</p>
<p>There are many ways an adversary may hijack the flow of execution, including by manipulating how the operating system locates programs to be executed. How the operating system locates libraries to be used by a program can also be intercepted. Locations where the operating system looks for programs/resources, such as file directories and in the case of Windows the Registry, could also be poisoned to include malicious payloads.
T1134.005 | SID-History Injection | Adversaries may use SID-History Injection to escalate privileges and bypass access controls. The Windows security identifier (SID) is a unique value that identifies a user or group account. SIDs are used by Windows security in both security descriptors and access tokens. (Citation: Microsoft SID) An account can hold additional SIDs in the SID-History Active Directory attribute (Citation: Microsoft SID-History Attribute), allowing inter-operable account migration between domains (e.g., all values in SID-History are included in access tokens).</p>
<p>With Domain Administrator (or equivalent) rights, harvested or well-known SID values (Citation: Microsoft Well Known SIDs Jun 2017) may be inserted into SID-History to enable impersonation of arbitrary users/groups such as Enterprise Administrators. This manipulation may result in elevated access to local resources and/or access to otherwise inaccessible domains via lateral movement techniques such as <a class="reference external" href="https://attack.mitre.org/techniques/T1021">Remote Services</a>, <a class="reference external" href="https://attack.mitre.org/techniques/T1077">Windows Admin Shares</a>, or <a class="reference external" href="https://attack.mitre.org/techniques/T1028">Windows Remote Management</a>.
T1134.004 | Parent PID Spoofing | Adversaries may spoof the parent process identifier (PPID) of a new process to evade process-monitoring defenses or to elevate privileges. New processes are typically spawned directly from their parent, or calling, process unless explicitly specified. One way of explicitly assigning the PPID of a new process is via the <code>CreateProcess</code> API call, which supports a parameter that defines the PPID to use.(Citation: DidierStevens SelectMyParent Nov 2009) This functionality is used by Windows features such as User Account Control (UAC) to correctly set the PPID after a requested elevated process is spawned by SYSTEM (typically via <code>svchost.exe</code> or <code>consent.exe</code>) rather than the current user context.(Citation: Microsoft UAC Nov 2018)</p>
<p>Adversaries may abuse these mechanisms to evade defenses, such as those blocking processes spawning directly from Office documents, and analysis targeting unusual/potentially malicious parent-child process relationships, such as spoofing the PPID of <a class="reference external" href="https://attack.mitre.org/techniques/T1086">PowerShell</a>/<a class="reference external" href="https://attack.mitre.org/techniques/T1085">Rundll32</a> to be <code>explorer.exe</code> rather than an Office document delivered as part of <a class="reference external" href="https://attack.mitre.org/techniques/T1566/001">Spearphishing Attachment</a>.(Citation: CounterCept PPID Spoofing Dec 2018) This spoofing could be executed via <a class="reference external" href="https://attack.mitre.org/techniques/T1059/005">Visual Basic</a> within a malicious Office document or any code that can perform <a class="reference external" href="https://attack.mitre.org/techniques/T1106">Native API</a>.(Citation: CTD PPID Spoofing Macro Mar 2019)(Citation: CounterCept PPID Spoofing Dec 2018)</p>
<p>Explicitly assigning the PPID may also enable elevated privileges given appropriate access rights to the parent process. For example, an adversary in a privileged user context (i.e. administrator) may spawn a new process and assign the parent as a process running as SYSTEM (such as <code>lsass.exe</code>), causing the new process to be elevated via the inherited access token.(Citation: XPNSec PPID Nov 2017)
T1134.003 | Make and Impersonate Token | Adversaries may make and impersonate tokens to escalate privileges and bypass access controls. If an adversary has a username and password but the user is not logged onto the system, the adversary can then create a logon session for the user using the <code>LogonUser</code> function. The function will return a copy of the new session‚Äôs access token and the adversary can use <code>SetThreadToken</code> to assign the token to a thread.
T1134.002 | Create Process with Token | Adversaries may create a new process with a duplicated token to escalate privileges and bypass access controls. An adversary can duplicate a desired access token with <code>DuplicateToken(Ex)</code> and use it with <code>CreateProcessWithTokenW</code> to create a new process running under the security context of the impersonated user. This is useful for creating a new process under the security context of a different user.
T1134.001 | Token Impersonation/Theft | Adversaries may duplicate then impersonate another user‚Äôs token to escalate privileges and bypass access controls. An adversary can create a new access token that duplicates an existing token using <code>DuplicateToken(Ex)</code>. The token can then be used with <code>ImpersonateLoggedOnUser</code> to allow the calling thread to impersonate a logged on user‚Äôs security context, or with <code>SetThreadToken</code> to assign the impersonated token to a thread.</p>
<p>An adversary may do this when they have a specific, existing process they want to assign the new token to. For example, this may be useful for when the target user has a non-network logon session on the system.
T1548.004 | Elevated Execution with Prompt | Adversaries may leverage the <code>AuthorizationExecuteWithPrivileges</code> API to escalate privileges by prompting the user for credentials.(Citation: AppleDocs AuthorizationExecuteWithPrivileges) The purpose of this API is to give application developers an easy way to perform operations with root privileges, such as for application installation or updating. This API does not validate that the program requesting root privileges comes from a reputable source or has been maliciously modified.</p>
<p>Although this API is deprecated, it still fully functions in the latest releases of macOS. When calling this API, the user will be prompted to enter their credentials but no checks on the origin or integrity of the program are made. The program calling the API may also load world writable files which can be modified to perform malicious behavior with elevated privileges.</p>
<p>Adversaries may abuse <code>AuthorizationExecuteWithPrivileges</code> to obtain root privileges in order to install malicious software on victims and install persistence mechanisms.(Citation: Death by 1000 installers; it‚Äôs all broken!)(Citation: Carbon Black Shlayer Feb 2019)(Citation: OSX Coldroot RAT) This technique may be combined with <a class="reference external" href="https://attack.mitre.org/techniques/T1036">Masquerading</a> to trick the user into granting escalated privileges to malicious code.(Citation: Death by 1000 installers; it‚Äôs all broken!)(Citation: Carbon Black Shlayer Feb 2019) This technique has also been shown to work by modifying legitimate programs present on the machine that make use of this API.(Citation: Death by 1000 installers; it‚Äôs all broken!)
T1548.003 | Sudo and Sudo Caching | Adversaries may perform sudo caching and/or use the suoders file to elevate privileges. Adversaries may do this to execute commands as other users or spawn processes with higher privileges.</p>
<p>Within Linux and MacOS systems, sudo (sometimes referred to as ‚Äúsuperuser do‚Äù) allows users to perform commands from terminals with elevated privileges and to control who can perform these commands on the system. The <code>sudo</code> command ‚Äúallows a system administrator to delegate authority to give certain users (or groups of users) the ability to run some (or all) commands as root or another user while providing an audit trail of the commands and their arguments.‚Äù(Citation: sudo man page 2018) Since sudo was made for the system administrator, it has some useful configuration features such as a <code>timestamp_timeout</code>, which is the amount of time in minutes between instances of <code>sudo</code> before it will re-prompt for a password. This is because <code>sudo</code> has the ability to cache credentials for a period of time. Sudo creates (or touches) a file at <code>/var/db/sudo</code> with a timestamp of when sudo was last run to determine this timeout. Additionally, there is a <code>tty_tickets</code> variable that treats each new tty (terminal session) in isolation. This means that, for example, the sudo timeout of one tty will not affect another tty (you will have to type the password again).</p>
<p>The sudoers file, <code>/etc/sudoers</code>, describes which users can run which commands and from which terminals. This also describes which commands users can run as other users or groups. This provides the principle of least privilege such that users are running in their lowest possible permissions for most of the time and only elevate to other users or permissions as needed, typically by prompting for a password. However, the sudoers file can also specify when to not prompt users for passwords with a line like <code>user1 ALL=(ALL) NOPASSWD: ALL</code> (Citation: OSX.Dok Malware). Elevated privileges are required to edit this file though.</p>
<p>Adversaries can also abuse poor configurations of these mechanisms to escalate privileges without needing the user‚Äôs password. For example, <code>/var/db/sudo</code>‚Äôs timestamp can be monitored to see if it falls within the <code>timestamp_timeout</code> range. If it does, then malware can execute sudo commands without needing to supply the user‚Äôs password. Additional, if <code>tty_tickets</code> is disabled, adversaries can do this from any tty for that user.</p>
<p>In the wild, malware has disabled <code>tty_tickets</code> to potentially make scripting easier by issuing <code>echo ‚ÄòDefaults !tty_tickets‚Äô &gt;&gt; /etc/sudoers</code> (Citation: cybereason osx proton). In order for this change to be reflected, the malware also issued <code>killall Terminal</code>. As of macOS Sierra, the sudoers file has <code>tty_tickets</code> enabled by default.
T1548.002 | Bypass User Access Control | Adversaries may bypass UAC mechanisms to elevate process privileges on system. Windows User Account Control (UAC) allows a program to elevate its privileges (tracked as integrity levels ranging from low to high) to perform a task under administrator-level permissions, possibly by prompting the user for confirmation. The impact to the user ranges from denying the operation under high enforcement to allowing the user to perform the action if they are in the local administrators group and click through the prompt or allowing them to enter an administrator password to complete the action. (Citation: TechNet How UAC Works)</p>
<p>If the UAC protection level of a computer is set to anything but the highest level, certain Windows programs can elevate privileges or execute some elevated <a class="reference external" href="https://attack.mitre.org/techniques/T1559/001">Component Object Model</a> objects without prompting the user through the UAC notification box. (Citation: TechNet Inside UAC) (Citation: MSDN COM Elevation) An example of this is use of <a class="reference external" href="https://attack.mitre.org/techniques/T1218/011">Rundll32</a> to load a specifically crafted DLL which loads an auto-elevated <a class="reference external" href="https://attack.mitre.org/techniques/T1559/001">Component Object Model</a> object and performs a file operation in a protected directory which would typically require elevated access. Malicious software may also be injected into a trusted process to gain elevated privileges without prompting a user.(Citation: Davidson Windows)</p>
<p>Many methods have been discovered to bypass UAC. The Github readme page for UACME contains an extensive list of methods(Citation: Github UACMe) that have been discovered and implemented, but may not be a comprehensive list of bypasses. Additional bypass methods are regularly discovered and some used in the wild, such as:</p>
<ul class="simple">
<li><p><code>eventvwr.exe</code> can auto-elevate and execute a specified binary or script.(Citation: enigma0x3 Fileless UAC Bypass)(Citation: Fortinet Fareit)</p></li>
</ul>
<p>Another bypass is possible through some lateral movement techniques if credentials for an account with administrator privileges are known, since UAC is a single system security mechanism, and the privilege or integrity of a process running on one system will be unknown on remote systems and default to high integrity.(Citation: SANS UAC Bypass)
T1548.001 | Setuid and Setgid | An adversary may perform shell escapes or exploit vulnerabilities in an application with the setsuid or setgid bits to get code running in a different user‚Äôs context. On Linux or macOS, when the setuid or setgid bits are set for an application, the application will run with the privileges of the owning user or group respectively. (Citation: setuid man page). Normally an application is run in the current user‚Äôs context, regardless of which user or group owns the application. However, there are instances where programs need to be executed in an elevated context to function properly, but the user running them doesn‚Äôt need the elevated privileges.</p>
<p>Instead of creating an entry in the sudoers file, which must be done by root, any user can specify the setuid or setgid flag to be set for their own applications. These bits are indicated with an ‚Äús‚Äù instead of an ‚Äúx‚Äù when viewing a file‚Äôs attributes via <code>ls -l</code>. The <code>chmod</code> program can set these bits with via bitmasking, <code>chmod 4777 [file]</code> or via shorthand naming, <code>chmod u+s [file]</code>.</p>
<p>Adversaries can use this mechanism on their own malware to make sure they‚Äôre able to execute in elevated contexts in the future.(Citation: OSX Keydnap malware).
T1548 | Abuse Elevation Control Mechanism | Adversaries may circumvent mechanisms designed to control elevate privileges to gain higher-level permissions. Most modern systems contain native elevation control mechanisms that are intended to limit privileges that a user can perform on a machine. Authorization has to be granted to specific users in order to perform tasks that can be considered of higher risk. An adversary can perform several methods to take advantage of built-in control mechanisms in order to escalate privileges on a system.
T1547.011 | Plist Modification | Adversaries may modify plist files to run a program during system boot or user login. Property list (plist) files contain all of the information that macOS and OS X uses to configure applications and services. These files are UTF-8 encoded and formatted like XML documents via a series of keys surrounded by &lt; &gt;. They detail when programs should execute, file paths to the executables, program arguments, required OS permissions, and many others. plists are located in certain locations depending on their purpose such as <code>/Library/Preferences</code> (which execute with elevated privileges) and <code>~/Library/Preferences</code> (which execute with a user‚Äôs privileges).</p>
<p>Adversaries can modify plist files to execute their code as part of establishing persistence. plists may also be used to elevate privileges since they may execute in the context of another user.(Citation: Sofacy Komplex Trojan)</p>
<p>A specific plist used for execution at login is <code>com.apple.loginitems.plist</code>.(Citation: Methods of Mac Malware Persistence) Applications under this plist run under the logged in user‚Äôs context, and will be started every time the user logs in. Login items installed using the Service Management Framework are not visible in the System Preferences and can only be removed by the application that created them.(Citation: Adding Login Items) Users have direct control over login items installed using a shared file list which are also visible in System Preferences (Citation: Adding Login Items). Some of these applications can open visible dialogs to the user, but they don‚Äôt all have to since there is an option to ‚Äúhide‚Äù the window. If an adversary can register their own login item or modified an existing one, then they can use it to execute their code for a persistence mechanism each time the user logs in (Citation: Malware Persistence on OS X) (Citation: OSX.Dok Malware). The API method <code> SMLoginItemSetEnabled</code> can be used to set Login Items, but scripting languages like <a class="reference external" href="https://attack.mitre.org/techniques/T1059/002">AppleScript</a> can do this as well. (Citation: Adding Login Items)
T1547.010 | Port Monitors | Adversaries may use port monitors to run an attacker supplied DLL during system boot for persistence or privilege escalation. A port monitor can be set through the <code>AddMonitor</code> API call to set a DLL to be loaded at startup. (Citation: AddMonitor) This DLL can be located in <code>C:\Windows\System32</code> and will be loaded by the print spooler service, spoolsv.exe, on boot. The spoolsv.exe process also runs under SYSTEM level permissions. (Citation: Bloxham) Alternatively, an arbitrary DLL can be loaded if permissions allow writing a fully-qualified pathname for that DLL to <code>HKLM\SYSTEM\CurrentControlSet\Control\Print\Monitors</code>.</p>
<p>The Registry key contains entries for the following:</p>
<ul class="simple">
<li><p>Local Port</p></li>
<li><p>Standard TCP/IP Port</p></li>
<li><p>USB Monitor</p></li>
<li><p>WSD Port</p></li>
</ul>
<p>Adversaries can use this technique to load malicious code at startup that will persist on system reboot and execute as SYSTEM.
T1547.009 | Shortcut Modification | Adversaries may create or edit shortcuts to run a program during system boot or user login. Shortcuts or symbolic links are ways of referencing other files or programs that will be opened or executed when the shortcut is clicked or executed by a system startup process.</p>
<p>Adversaries could use shortcuts to execute their tools for persistence. They may create a new shortcut as a means of indirection that may use <a class="reference external" href="https://attack.mitre.org/techniques/T1036">Masquerading</a> to look like a legitimate program. Adversaries could also edit the target path or entirely replace an existing shortcut so their tools will be executed instead of the intended legitimate program.
T1547.008 | LSASS Driver | Adversaries may modify or add LSASS drivers to obtain persistence on compromised systems. The Windows security subsystem is a set of components that manage and enforce the security policy for a computer or domain. The Local Security Authority (LSA) is the main component responsible for local security policy and user authentication. The LSA includes multiple dynamic link libraries (DLLs) associated with various other security functions, all of which run in the context of the LSA Subsystem Service (LSASS) lsass.exe process. (Citation: Microsoft Security Subsystem)</p>
<p>Adversaries may target LSASS drivers to obtain persistence. By either replacing or adding illegitimate drivers (e.g., <a class="reference external" href="https://attack.mitre.org/techniques/T1574">Hijack Execution Flow</a>), an adversary can use LSA operations to continuously execute malicious payloads.
T1547.007 | Re-opened Applications | Adversaries may modify plist files to automatically run an application when a user logs in. Starting in Mac OS X 10.7 (Lion), users can specify certain applications to be re-opened when a user logs into their machine after reboot. While this is usually done via a Graphical User Interface (GUI) on an app-by-app basis, there are property list files (plist) that contain this information as well located at <code>~/Library/Preferences/com.apple.loginwindow.plist</code> and <code>~/Library/Preferences/ByHost/com.apple.loginwindow.* .plist</code>.</p>
<p>An adversary can modify one of these files directly to include a link to their malicious executable to provide a persistence mechanism each time the user reboots their machine (Citation: Methods of Mac Malware Persistence).
T1547.006 | Kernel Modules and Extensions | Adversaries may modify the kernel to automatically execute programs on system boot. Loadable Kernel Modules (LKMs) are pieces of code that can be loaded and unloaded into the kernel upon demand. They extend the functionality of the kernel without the need to reboot the system. For example, one type of module is the device driver, which allows the kernel to access hardware connected to the system. (Citation: Linux Kernel Programming)</p>
<p>When used maliciously, LKMs can be a type of kernel-mode <a class="reference external" href="https://attack.mitre.org/techniques/T1014">Rootkit</a> that run with the highest operating system privilege (Ring 0). (Citation: Linux Kernel Module Programming Guide)¬†Common features of LKM based rootkits include: hiding itself, selective hiding of files, processes and network activity, as well as log tampering, providing authenticated backdoors and enabling root access to non-privileged users. (Citation: iDefense Rootkit Overview)</p>
<p>Kernel extensions, also called kext, are used for macOS to load functionality onto a system similar to LKMs for Linux. They are loaded and unloaded through <code>kextload</code> and <code>kextunload</code> commands.</p>
<p>Adversaries can use LKMs and kexts to covertly persist on a system and elevate privileges. Examples have been found in the wild and there are some open source projects. (Citation: Volatility Phalanx2) (Citation: CrowdStrike Linux Rootkit) (Citation: GitHub Reptile) (Citation: GitHub Diamorphine)(Citation: RSAC 2015 San Francisco Patrick Wardle) (Citation: Synack Secure Kernel Extension Broken)(Citation: Securelist Ventir) (Citation: Trend Micro Skidmap)
T1547.005 | Security Support Provider | Adversaries may abuse security support providers (SSPs) to execute DLLs when the system boots. Windows SSP DLLs are loaded into the Local Security Authority (LSA) process at system start. Once loaded into the LSA, SSP DLLs have access to encrypted and plaintext passwords that are stored in Windows, such as any logged-on user‚Äôs Domain password or smart card PINs.</p>
<p>The SSP configuration is stored in two Registry keys: <code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa\Security Packages</code> and <code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa\OSConfig\Security Packages</code>. An adversary may modify these Registry keys to add new SSPs, which will be loaded the next time the system boots, or when the AddSecurityPackage Windows API function is called.(Citation: Graeber 2014)
T1547.004 | Winlogon Helper DLL | Adversaries may abuse features of Winlogon to execute DLLs and/or executables when a user logs in. Winlogon.exe is a Windows component responsible for actions at logon/logoff as well as the secure attention sequence (SAS) triggered by Ctrl-Alt-Delete. Registry entries in <code>HKLM\Software[\Wow6432Node\]\Microsoft\Windows NT\CurrentVersion\Winlogon&lt;/code&gt; and <code>HKCU\Software\Microsoft\Windows NT\CurrentVersion\Winlogon&lt;/code&gt; are used to manage additional helper programs and functionalities that support Winlogon. (Citation: Cylance Reg Persistence Sept 2013)</p>
<p>Malicious modifications to these Registry keys may cause Winlogon to load and execute malicious DLLs and/or executables. Specifically, the following subkeys have been known to be possibly vulnerable to abuse: (Citation: Cylance Reg Persistence Sept 2013)</p>
<ul class="simple">
<li><p>Winlogon\Notify - points to notification package DLLs that handle Winlogon events</p></li>
<li><p>Winlogon\Userinit - points to userinit.exe, the user initialization program executed when a user logs on</p></li>
<li><p>Winlogon\Shell - points to explorer.exe, the system shell executed when a user logs on</p></li>
</ul>
<p>Adversaries may take advantage of these features to repeatedly execute malicious code and establish persistence.
T1547.003 | Time Providers | Adversaries may abuse time providers to execute DLLs when the system boots. The Windows Time service (W32Time) enables time synchronization across and within domains. (Citation: Microsoft W32Time Feb 2018) W32Time time providers are responsible for retrieving time stamps from hardware/network resources and outputting these values to other network clients. (Citation: Microsoft TimeProvider)</p>
<p>Time providers are implemented as dynamic-link libraries (DLLs) that are registered in the subkeys of  <code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\W32Time\TimeProviders&lt;/code&gt;. (Citation: Microsoft TimeProvider) The time provider manager, directed by the service control manager, loads and starts time providers listed and enabled under this key at system startup and/or whenever parameters are changed. (Citation: Microsoft TimeProvider)</p>
<p>Adversaries may abuse this architecture to establish persistence, specifically by registering and enabling a malicious DLL as a time provider. Administrator privileges are required for time provider registration, though execution will run in context of the Local Service account. (Citation: Github W32Time Oct 2017)
T1546.014 | Emond | Adversaries may gain persistence and elevate privileges by executing malicious content triggered by the Event Monitor Daemon (emond). Emond is a <a class="reference external" href="https://attack.mitre.org/techniques/T1543/004">Launch Daemon</a> that accepts events from various services, runs them through a simple rules engine, and takes action. The emond binary at <code>/sbin/emond</code> will load any rules from the <code>/etc/emond.d/rules/</code> directory and take action once an explicitly defined event takes place.</p>
<p>The rule files are in the plist format and define the name, event type, and action to take. Some examples of event types include system startup and user authentication. Examples of actions are to run a system command or send an email. The emond service will not launch if there is no file present in the QueueDirectories path <code>/private/var/db/emondClients</code>, specified in the <a class="reference external" href="https://attack.mitre.org/techniques/T1543/004">Launch Daemon</a> configuration file at<code>/System/Library/LaunchDaemons/com.apple.emond.plist</code>.(Citation: xorrior emond Jan 2018)(Citation: magnusviri emond Apr 2016)(Citation: sentinelone macos persist Jun 2019)</p>
<p>Adversaries may abuse this service by writing a rule to execute commands when a defined event occurs, such as system start up or user authentication.(Citation: xorrior emond Jan 2018)(Citation: magnusviri emond Apr 2016)(Citation: sentinelone macos persist Jun 2019) Adversaries may also be able to escalate privileges from administrator to root as the emond service is executed with root privileges by the <a class="reference external" href="https://attack.mitre.org/techniques/T1543/004">Launch Daemon</a> service.
T1546.013 | PowerShell Profile | Adversaries may gain persistence and elevate privileges by executing malicious content triggered by PowerShell profiles. A PowerShell profile  (<code>profile.ps1</code>) is a script that runs when <a class="reference external" href="https://attack.mitre.org/techniques/T1059/001">PowerShell</a> starts and can be used as a logon script to customize user environments.</p>
<p><a class="reference external" href="https://attack.mitre.org/techniques/T1059/001">PowerShell</a> supports several profiles depending on the user or host program. For example, there can be different profiles for <a class="reference external" href="https://attack.mitre.org/techniques/T1059/001">PowerShell</a> host programs such as the PowerShell console, PowerShell ISE or Visual Studio Code. An administrator can also configure a profile that applies to all users and host programs on the local computer. (Citation: Microsoft About Profiles)</p>
<p>Adversaries may modify these profiles to include arbitrary commands, functions, modules, and/or <a class="reference external" href="https://attack.mitre.org/techniques/T1059/001">PowerShell</a> drives to gain persistence. Every time a user opens a <a class="reference external" href="https://attack.mitre.org/techniques/T1059/001">PowerShell</a> session the modified script will be executed unless the <code>-NoProfile</code> flag is used when it is launched. (Citation: ESET Turla PowerShell May 2019)</p>
<p>An adversary may also be able to escalate privileges if a script in a PowerShell profile is loaded and executed by an account with higher privileges, such as a domain administrator. (Citation: Wits End and Shady PowerShell Profiles)
T1546.012 | Image File Execution Options Injection | Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by Image File Execution Options (IEFO) debuggers. IEFOs enable a developer to attach a debugger to an application. When a process is created, a debugger present in an application‚Äôs IFEO will be prepended to the application‚Äôs name, effectively launching the new process under the debugger (e.g., <code>C:\dbg\ntsd.exe -g  notepad.exe</code>). (Citation: Microsoft Dev Blog IFEO Mar 2010)</p>
<p>IFEOs can be set directly via the Registry or in Global Flags via the GFlags tool. (Citation: Microsoft GFlags Mar 2017) IFEOs are represented as <code>Debugger</code> values in the Registry under <code>HKLM\SOFTWARE{\Wow6432Node}\Microsoft\Windows NT\CurrentVersion\Image File Execution Options&lt;executable&gt;</code> where <code>&lt;executable&gt;</code> is the binary on which the debugger is attached. (Citation: Microsoft Dev Blog IFEO Mar 2010)</p>
<p>IFEOs can also enable an arbitrary monitor program to be launched when a specified program silently exits (i.e. is prematurely terminated by itself or a second, non kernel-mode process). (Citation: Microsoft Silent Process Exit NOV 2017) (Citation: Oddvar Moe IFEO APR 2018) Similar to debuggers, silent exit monitoring can be enabled through GFlags and/or by directly modifying IEFO and silent process exit Registry values in <code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit&lt;/code&gt;. (Citation: Microsoft Silent Process Exit NOV 2017) (Citation: Oddvar Moe IFEO APR 2018)</p>
<p>Similar to <a class="reference external" href="https://attack.mitre.org/techniques/T1546/008">Accessibility Features</a>, on Windows Vista and later as well as Windows Server 2008 and later, a Registry key may be modified that configures ‚Äúcmd.exe,‚Äù or another program that provides backdoor access, as a ‚Äúdebugger‚Äù for an accessibility program (ex: utilman.exe). After the Registry is modified, pressing the appropriate key combination at the login screen while at the keyboard or when connected with <a class="reference external" href="https://attack.mitre.org/techniques/T1021/001">Remote Desktop Protocol</a> will cause the ‚Äúdebugger‚Äù program to be executed with SYSTEM privileges. (Citation: Tilbury 2014)</p>
<p>Similar to <a class="reference external" href="https://attack.mitre.org/techniques/T1055">Process Injection</a>, these values may also be abused to obtain privilege escalation by causing a malicious executable to be loaded and run in the context of separate processes on the computer. (Citation: Endgame Process Injection July 2017) Installing IFEO mechanisms may also provide Persistence via continuous triggered invocation.</p>
<p>Malware may also use IFEO to <a class="reference external" href="https://attack.mitre.org/techniques/T1562">Impair Defenses</a> by registering invalid debuggers that redirect and effectively disable various system and security applications. (Citation: FSecure Hupigon) (Citation: Symantec Ushedix June 2008)
T1546.011 | Application Shimming | Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by application shims. The Microsoft Windows Application Compatibility Infrastructure/Framework (Application Shim) was created to allow for backward compatibility of software as the operating system codebase changes over time. For example, the application shimming feature allows developers to apply fixes to applications (without rewriting code) that were created for Windows XP so that it will work with Windows 10. (Citation: Endgame Process Injection July 2017)</p>
<p>Within the framework, shims are created to act as a buffer between the program (or more specifically, the Import Address Table) and the Windows OS. When a program is executed, the shim cache is referenced to determine if the program requires the use of the shim database (.sdb). If so, the shim database uses hooking to redirect the code as necessary in order to communicate with the OS.</p>
<p>A list of all shims currently installed by the default Windows installer (sdbinst.exe) is kept in:</p>
<ul class="simple">
<li><p><code>%WINDIR%\AppPatch\sysmain.sdb</code> and</p></li>
<li><p><code>hklm\software\microsoft\windows nt\currentversion\appcompatflags\installedsdb</code></p></li>
</ul>
<p>Custom databases are stored in:</p>
<ul class="simple">
<li><p><code>%WINDIR%\AppPatch\custom &amp; %WINDIR%\AppPatch\AppPatch64\Custom</code> and</p></li>
<li><p><code>hklm\software\microsoft\windows nt\currentversion\appcompatflags\custom</code></p></li>
</ul>
<p>To keep shims secure, Windows designed them to run in user mode so they cannot modify the kernel and you must have administrator privileges to install a shim. However, certain shims can be used to <a class="reference external" href="https://attack.mitre.org/techniques/T1548/002">Bypass User Access Control</a> (UAC and RedirectEXE), inject DLLs into processes (InjectDLL), disable Data Execution Prevention (DisableNX) and Structure Exception Handling (DisableSEH), and intercept memory addresses (GetProcAddress).</p>
<p>Utilizing these shims may allow an adversary to perform several malicious acts such as elevate privileges, install backdoors, disable defenses like Windows Defender, etc. (Citation: FireEye Application Shimming) Shims can also be abused to establish persistence by continuously being invoked by affected programs.
T1547.002 | Authentication Package | Adversaries may abuse authentication packages to execute DLLs when the system boots. Windows authentication package DLLs are loaded by the Local Security Authority (LSA) process at system start. They provide support for multiple logon processes and multiple security protocols to the operating system. (Citation: MSDN Authentication Packages)</p>
<p>Adversaries can use the autostart mechanism provided by LSA authentication packages for persistence by placing a reference to a binary in the Windows Registry location <code>HKLM\SYSTEM\CurrentControlSet\Control\Lsa&lt;/code&gt; with the key value of <code>‚ÄùAuthentication Packages‚Äù=&lt;target binary&gt;</code>. The binary will then be executed by the system when the authentication packages are loaded.
T1546.010 | AppInit DLLs | Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by AppInit DLLs loaded into processes. Dynamic-link libraries (DLLs) that are specified in the <code>AppInit_DLLs</code> value in the Registry keys <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Windows</code> or <code>HKEY_LOCAL_MACHINE\Software\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows</code> are loaded by user32.dll into every process that loads user32.dll. In practice this is nearly every program, since user32.dll is a very common library. (Citation: Endgame Process Injection July 2017)</p>
<p>Similar to Process Injection, these values can be abused to obtain elevated privileges by causing a malicious DLL to be loaded and run in the context of separate processes on the computer. (Citation: AppInit Registry) Malicious AppInit DLLs may also provide persistence by continuously being triggered by API activity.</p>
<p>The AppInit DLL functionality is disabled in Windows 8 and later versions when secure boot is enabled. (Citation: AppInit Secure Boot)
T1546.009 | AppCert DLLs | Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by AppCert DLLs loaded into processes. Dynamic-link libraries (DLLs) that are specified in the <code>AppCertDLLs</code> Registry key under <code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager&lt;/code&gt; are loaded into every process that calls the ubiquitously used application programming interface (API) functions <code>CreateProcess</code>, <code>CreateProcessAsUser</code>, <code>CreateProcessWithLoginW</code>, <code>CreateProcessWithTokenW</code>, or <code>WinExec</code>. (Citation: Endgame Process Injection July 2017)</p>
<p>Similar to <a class="reference external" href="https://attack.mitre.org/techniques/T1055">Process Injection</a>, this value can be abused to obtain elevated privileges by causing a malicious DLL to be loaded and run in the context of separate processes on the computer. Malicious AppCert DLLs may also provide persistence by continuously being triggered by API activity.
T1546.008 | Accessibility Features | Adversaries may establish persistence and/or elevate privileges by executing malicious content triggered by accessibility features. Windows contains accessibility features that may be launched with a key combination before a user has logged in (ex: when the user is on the Windows logon screen). An adversary can modify the way these programs are launched to get a command prompt or backdoor without logging in to the system.</p>
<p>Two common accessibility programs are <code>C:\Windows\System32\sethc.exe</code>, launched when the shift key is pressed five times and <code>C:\Windows\System32\utilman.exe</code>, launched when the Windows + U key combination is pressed. The sethc.exe program is often referred to as ‚Äústicky keys‚Äù, and has been used by adversaries for unauthenticated access through a remote desktop login screen. (Citation: FireEye Hikit Rootkit)</p>
<p>Depending on the version of Windows, an adversary may take advantage of these features in different ways. Common methods used by adversaries include replacing accessibility feature binaries or pointers/references to these binaries in the Registry. In newer versions of Windows, the replaced binary needs to be digitally signed for x64 systems, the binary must reside in <code>%systemdir%&lt;/code&gt;, and it must be protected by Windows File or Resource Protection (WFP/WRP). (Citation: DEFCON2016 Sticky Keys) The <a class="reference external" href="https://attack.mitre.org/techniques/T1546/012">Image File Execution Options Injection</a> debugger method was likely discovered as a potential workaround because it does not require the corresponding accessibility feature binary to be replaced.</p>
<p>For simple binary replacement on Windows XP and later as well as and Windows Server 2003/R2 and later, for example, the program (e.g., <code>C:\Windows\System32\utilman.exe</code>) may be replaced with ‚Äúcmd.exe‚Äù (or another program that provides backdoor access). Subsequently, pressing the appropriate key combination at the login screen while sitting at the keyboard or when connected over <a class="reference external" href="https://attack.mitre.org/techniques/T1021/001">Remote Desktop Protocol</a> will cause the replaced file to be executed with SYSTEM privileges. (Citation: Tilbury 2014)</p>
<p>Other accessibility features exist that may also be leveraged in a similar fashion: (Citation: DEFCON2016 Sticky Keys)(Citation: Narrator Accessibility Abuse)</p>
<ul class="simple">
<li><p>On-Screen Keyboard: <code>C:\Windows\System32\osk.exe</code></p></li>
<li><p>Magnifier: <code>C:\Windows\System32\Magnify.exe</code></p></li>
<li><p>Narrator: <code>C:\Windows\System32\Narrator.exe</code></p></li>
<li><p>Display Switcher: <code>C:\Windows\System32\DisplaySwitch.exe</code></p></li>
<li><p>App Switcher: <code>C:\Windows\System32\AtBroker.exe</code>
T1546.007 | Netsh Helper DLL | Adversaries may establish persistence by executing malicious content triggered by Netsh Helper DLLs. Netsh.exe (also referred to as Netshell) is a command-line scripting utility used to interact with the network configuration of a system. It contains functionality to add helper DLLs for extending functionality of the utility. (Citation: TechNet Netsh) The paths to registered netsh.exe helper DLLs are entered into the Windows Registry at <code>HKLM\SOFTWARE\Microsoft\Netsh</code>.</p></li>
</ul>
<p>Adversaries can use netsh.exe helper DLLs to trigger execution of arbitrary code in a persistent manner. This execution would take place anytime netsh.exe is executed, which could happen automatically, with another persistence technique, or if other software (ex: VPN) is present on the system that executes netsh.exe as part of its normal functionality. (Citation: Github Netsh Helper CS Beacon)(Citation: Demaske Netsh Persistence)
T1546.006 | LC_LOAD_DYLIB Addition | Adversaries may establish persistence by executing malicious content triggered by the execution of tainted binaries. Mach-O binaries have a series of headers that are used to perform certain operations when a binary is loaded. The LC_LOAD_DYLIB header in a Mach-O binary tells macOS and OS X which dynamic libraries (dylibs) to load during execution time. These can be added ad-hoc to the compiled binary as long as adjustments are made to the rest of the fields and dependencies. (Citation: Writing Bad Malware for OSX) There are tools available to perform these changes.</p>
<p>Adversaries may modify Mach-O binary headers to load and execute malicious dylibs every time the binary is executed. Although any changes will invalidate digital signatures on binaries because the binary is being modified, this can be remediated by simply removing the LC_CODE_SIGNATURE command from the binary so that the signature isn‚Äôt checked at load time. (Citation: Malware Persistence on OS X)
T1546.005 | Trap | Adversaries may establish persistence by executing malicious content triggered by an interrupt signal. The <code>trap</code> command allows programs and shells to specify commands that will be executed upon receiving interrupt signals. A common situation is a script allowing for graceful termination and handling of common keyboard interrupts like <code>ctrl+c</code> and <code>ctrl+d</code>.</p>
<p>Adversaries can use this to register code to be executed when the shell encounters specific interrupts as a persistence mechanism. Trap commands are of the following format <code>trap ‚Äòcommand list‚Äô signals</code> where ‚Äúcommand list‚Äù will be executed when ‚Äúsignals‚Äù are received.(Citation: Trap Manual)(Citation: Cyberciti Trap Statements)
T1546.004 | .bash_profile and .bashrc | Adversaries may establish persistence by executing malicious content triggered by a user‚Äôs shell. <code>~/.bash_profile</code> and <code>~/.bashrc</code> are shell scripts that contain shell commands. These files are executed in a user‚Äôs context when a new shell opens or when a user logs in so that their environment is set correctly.</p>
<p><code>~/.bash_profile</code> is executed for login shells and <code>~/.bashrc</code> is executed for interactive non-login shells. This means that when a user logs in (via username and password) to the console (either locally or remotely via something like SSH), the <code>~/.bash_profile</code> script is executed before the initial command prompt is returned to the user. After that, every time a new shell is opened, the <code>~/.bashrc</code> script is executed. This allows users more fine-grained control over when they want certain commands executed. These shell scripts are meant to be written to by the local user to configure their own environment.</p>
<p>The macOS Terminal.app is a little different in that it runs a login shell by default each time a new terminal window is opened, thus calling <code>~/.bash_profile</code> each time instead of <code>~/.bashrc</code>.</p>
<p>Adversaries may abuse these shell scripts by inserting arbitrary shell commands that may be used to execute other binaries to gain persistence. Every time the user logs in or opens a new shell, the modified ~/.bash_profile and/or ~/.bashrc scripts will be executed.(Citation: amnesia malware)
T1546.003 | Windows Management Instrumentation Event Subscription | Adversaries may establish persistence and elevate privileges by executing malicious content triggered by a Windows Management Instrumentation (WMI) event subscription. WMI can be used to install event filters, providers, consumers, and bindings that execute code when a defined event occurs. Examples of events that may be subscribed to are the wall clock time, user loging, or the computer‚Äôs uptime. (Citation: Mandiant M-Trends 2015)</p>
<p>Adversaries may use the capabilities of WMI to subscribe to an event and execute arbitrary code when that event occurs, providing persistence on a system. (Citation: FireEye WMI SANS 2015) (Citation: FireEye WMI 2015) Adversaries may also compile WMI scripts into Windows Management Object (MOF) files (.mof extension) that can be used to create a malicious subscription. (Citation: Dell WMI Persistence) (Citation: Microsoft MOF May 2018)</p>
<p>WMI subscription execution is proxied by the WMI Provider Host process (WmiPrvSe.exe) and thus may result in elevated SYSTEM privileges.
T1546.002 | Screensaver | Adversaries may establish persistence by executing malicious content triggered by user inactivity. Screensavers are programs that execute after a configurable time of user inactivity and consist of Portable Executable (PE) files with a .scr file extension.(Citation: Wikipedia Screensaver) The Windows screensaver application scrnsave.scr is located in <code>C:\Windows\System32&lt;/code&gt;, and <code>C:\Windows\sysWOW64&lt;/code&gt;  on 64-bit Windows systems, along with screensavers included with base Windows installations.</p>
<p>The following screensaver settings are stored in the Registry (<code>HKCU\Control Panel\Desktop&lt;/code&gt;) and could be manipulated to achieve persistence:</p>
<ul class="simple">
<li><p><code>SCRNSAVE.exe</code> - set to malicious PE path</p></li>
<li><p><code>ScreenSaveActive</code> - set to ‚Äò1‚Äô to enable the screensaver</p></li>
<li><p><code>ScreenSaverIsSecure</code> - set to ‚Äò0‚Äô to not require a password to unlock</p></li>
<li><p><code>ScreenSaveTimeout</code> - sets user inactivity timeout before screensaver is executed</p></li>
</ul>
<p>Adversaries can use screensaver settings to maintain persistence by setting the screensaver to run malware after a certain timeframe of user inactivity. (Citation: ESET Gazer Aug 2017)
T1546.001 | Change Default File Association | Adversaries may establish persistence by executing malicious content triggered by a file type association. When a file is opened, the default program used to open the file (also called the file association or handler) is checked. File association selections are stored in the Windows Registry and can be edited by users, administrators, or programs that have Registry access (Citation: Microsoft Change Default Programs) (Citation: Microsoft File Handlers) or by administrators using the built-in assoc utility. (Citation: Microsoft Assoc Oct 2017) Applications can modify the file association for a given file extension to call an arbitrary program when a file with the given extension is opened.</p>
<p>System file associations are listed under <code>HKEY_CLASSES_ROOT.[extension]</code>, for example <code>HKEY_CLASSES_ROOT.txt</code>. The entries point to a handler for that extension located at <code>HKEY_CLASSES_ROOT[handler]</code>. The various commands are then listed as subkeys underneath the shell key at <code>HKEY_CLASSES_ROOT[handler]\shell[action]\command</code>. For example:</p>
<ul class="simple">
<li><p><code>HKEY_CLASSES_ROOT\txtfile\shell\open\command</code></p></li>
<li><p><code>HKEY_CLASSES_ROOT\txtfile\shell\print\command</code></p></li>
<li><p><code>HKEY_CLASSES_ROOT\txtfile\shell\printto\command</code></p></li>
</ul>
<p>The values of the keys listed are commands that are executed when the handler opens the file extension. Adversaries can modify these values to continually execute arbitrary commands. (Citation: TrendMicro TROJ-FAKEAV OCT 2012)
T1547.001 | Registry Run Keys / Startup Folder | Adversaries may achieve persistence by adding a program to a startup folder or referencing it with a Registry run key. Adding an entry to the ‚Äúrun keys‚Äù in the Registry or startup folder will cause the program referenced to be executed when a user logs in. (Citation: Microsoft Run Key) These programs will be executed under the context of the user and will have the account‚Äôs associated permissions level.</p>
<p>Placing a program within a startup folder will also cause that program to execute when a user logs in. There is a startup folder location for individual user accounts as well as a system-wide startup folder that will be checked regardless of which user account logs in. The startup folder path for the current user is <code>C:\Users[Username]\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</code>. The startup folder path for all users is <code>C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</code>.</p>
<p>The following run keys are created by default on Windows systems:</p>
<ul class="simple">
<li><p><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</code></p></li>
<li><p><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce</code></p></li>
<li><p><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run</code></p></li>
<li><p><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnce</code></p></li>
</ul>
<p>The <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunOnceEx</code> is also available but is not created by default on Windows Vista and newer. Registry run key entries can reference programs directly or list them as a dependency. (Citation: Microsoft RunOnceEx APR 2018) For example, it is possible to load a DLL at logon using a ‚ÄúDepend‚Äù key with RunOnceEx: <code>reg add HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx\0001\Depend /v 1 /d ‚ÄúC:\temp\evil[.]dll‚Äù</code> (Citation: Oddvar Moe RunOnceEx Mar 2018)</p>
<p>The following Registry keys can be used to set startup folder items for persistence:</p>
<ul class="simple">
<li><p><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders</code></p></li>
<li><p><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders</code></p></li>
<li><p><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders</code></p></li>
<li><p><code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders</code></p></li>
</ul>
<p>The following Registry keys can control automatic startup of services during boot:</p>
<ul class="simple">
<li><p><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</code></p></li>
<li><p><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce</code></p></li>
<li><p><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\RunServices</code></p></li>
<li><p><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunServices</code></p></li>
</ul>
<p>Using policy settings to specify startup programs creates corresponding values in either of two Registry keys:</p>
<ul class="simple">
<li><p><code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</code></p></li>
<li><p><code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run</code></p></li>
</ul>
<p>The Winlogon key controls actions that occur when a user logs on to a computer running Windows 7. Most of these actions are under the control of the operating system, but you can also add custom actions here. The <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit</code> and <code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell</code> subkeys can automatically launch programs.</p>
<p>Programs listed in the load value of the registry key <code>HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows</code> run when any user logs on.</p>
<p>By default, the multistring <code>BootExecute</code> value of the registry key <code>HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\Session Manager</code> is set to <code>autocheck autochk *</code>. This value causes Windows, at startup, to check the file-system integrity of the hard disks if the system has been shut down abnormally. Adversaries can add other programs or processes to this registry value which will automatically launch at boot.</p>
<p>Adversaries can use these configuration locations to execute malware, such as remote access tools, to maintain persistence through system reboots. Adversaries may also use <a class="reference external" href="https://attack.mitre.org/techniques/T1036">Masquerading</a> to make the Registry entries look as if they are associated with legitimate programs.
T1547 | Boot or Logon Autostart Execution | Adversaries may configure system settings to automatically execute a program during system boot or logon to maintain persistence or gain higher-level privileges on compromised systems. Operating systems may have mechanisms for automatically running a program on system boot or account logon.(Citation: Microsoft Run Key)(Citation: MSDN Authentication Packages)(Citation: Microsoft TimeProvider)(Citation: Cylance Reg Persistence Sept 2013)(Citation: Linux Kernel Programming)¬† These mechanisms may include automatically executing programs that are placed in specially designated directories or are referenced by repositories that store configuration information, such as the Windows Registry. An adversary may achieve the same goal by modifying or extending features of the kernel.</p>
<p>Since some boot or logon autostart programs run with higher privileges, an adversary may leverage these to elevate privileges.
T1546 | Event Triggered Execution | Adversaries may establish persistence and/or elevate privileges using system mechanisms that trigger execution based on specific events. Various operating systems have means to monitor and subscribe to events such as logons or other user activity such as running specific applications/binaries.</p>
<p>Adversaries may abuse these mechanisms as a means of maintaining persistent access to a victim via repeatedly executing malicious code. After gaining access to a victim system, adversaries may create/modify event triggers to point to malicious content that will be executed whenever the event trigger is invoked.</p>
<p>Since the execution can be proxied by an account with higher permissions, such as SYSTEM or service accounts, an adversary may be able to abuse these triggered execution mechanisms to escalate their privileges.
T1543.004 | Launch Daemon | Adversaries may create or modify launch daemons to repeatedly execute malicious payloads as part of persistence. Per Apple‚Äôs developer documentation, when macOS and OS X boot up, launchd is run to finish system initialization. This process loads the parameters for each launch-on-demand system-level daemon from the property list (plist) files found in <code>/System/Library/LaunchDaemons</code> and <code>/Library/LaunchDaemons</code> (Citation: AppleDocs Launch Agent Daemons). These LaunchDaemons have property list files which point to the executables that will be launched (Citation: Methods of Mac Malware Persistence).</p>
<p>Adversaries may install a new launch daemon that can be configured to execute at startup by using launchd or launchctl to load a plist into the appropriate directories  (Citation: OSX Malware Detection). The daemon name may be disguised by using a name from a related operating system or benign software (Citation: WireLurker). Launch Daemons may be created with administrator privileges, but are executed under root privileges, so an adversary may also use a service to escalate privileges from administrator to root.</p>
<p>The plist file permissions must be root:wheel, but the script or program that it points to has no such requirement. So, it is possible for poor configurations to allow an adversary to modify a current Launch Daemon‚Äôs executable and gain persistence or Privilege Escalation.
T1543.003 | Windows Service | Adversaries may create or modify Windows services to repeatedly execute malicious payloads as part of persistence. When Windows boots up, it starts programs or applications called services that perform background system functions.(Citation: TechNet Services) Windows service configuration information, including the file path to the service‚Äôs executable or recovery programs/commands, is stored in the Windows Registry. Service configurations can be modified using utilities such as sc.exe and <a class="reference external" href="https://attack.mitre.org/software/S0075">Reg</a>.</p>
<p>Adversaries may install a new service or modify an existing service by using system utilities to interact with services, by directly modifying the Registry, or by using custom tools to interact with the Windows API. Adversaries may configure services to execute at startup in order to persist on a system.</p>
<p>An adversary may also incorporate <a class="reference external" href="https://attack.mitre.org/techniques/T1036">Masquerading</a> by using a service name from a related operating system or benign software, or by modifying existing services to make detection analysis more challenging. Modifying existing services may interrupt their functionality or may enable services that are disabled or otherwise not commonly used.</p>
<p>Services may be created with administrator privileges but are executed under SYSTEM privileges, so an adversary may also use a service to escalate privileges from administrator to SYSTEM. Adversaries may also directly start services through <a class="reference external" href="https://attack.mitre.org/techniques/T1569/002">Service Execution</a>.
T1543.002 | Systemd Service | Adversaries may create or modify systemd services to repeatedly execute malicious payloads as part of persistence. The systemd service manager is commonly used for managing background daemon processes (also known as services) and other system resources.(Citation: Linux man-pages: systemd January 2014)(Citation: Freedesktop.org Linux systemd 29SEP2018) Systemd is the default initialization (init) system on many Linux distributions starting with Debian 8, Ubuntu 15.04, CentOS 7, RHEL 7, Fedora 15, and replaces legacy init systems including SysVinit and Upstart while remaining backwards compatible with the aforementioned init systems.</p>
<p>Systemd utilizes configuration files known as service units to control how services boot and under what conditions. By default, these unit files are stored in the <code>/etc/systemd/system</code> and <code>/usr/lib/systemd/system</code> directories and have the file extension <code>.service</code>. Each service unit file may contain numerous directives that can execute system commands:</p>
<ul class="simple">
<li><p>ExecStart, ExecStartPre, and ExecStartPost directives cover execution of commands when a services is started manually by ‚Äòsystemctl‚Äô or on system start if the service is set to automatically start.</p></li>
<li><p>ExecReload directive covers when a service restarts.</p></li>
<li><p>ExecStop and ExecStopPost directives cover when a service is stopped or manually by ‚Äòsystemctl‚Äô.</p></li>
</ul>
<p>Adversaries have used systemd functionality to establish persistent access to victim systems by creating and/or modifying service unit files that cause systemd to execute malicious commands at recurring intervals, such as at system boot.(Citation: Anomali Rocke March 2019)(Citation: gist Arch package compromise 10JUL2018)(Citation: Arch Linux Package Systemd Compromise BleepingComputer 10JUL2018)(Citation: acroread package compromised Arch Linux Mail 8JUL2018)</p>
<p>While adversaries typically require root privileges to create/modify service unit files in the <code>/etc/systemd/system</code> and <code>/usr/lib/systemd/system</code> directories, low privilege users can create/modify service unit files in directories such as <code>~/.config/systemd/user/</code> to achieve user-level persistence.(Citation: Rapid7 Service Persistence 22JUNE2016)
T1543.001 | Launch Agent | Adversaries may create or modify launch agents to repeatedly execute malicious payloads as part of persistence. Per Apple‚Äôs developer documentation, when a user logs in, a per-user launchd process is started which loads the parameters for each launch-on-demand user agent from the property list (plist) files found in <code>/System/Library/LaunchAgents</code>, <code>/Library/LaunchAgents</code>, and <code>$HOME/Library/LaunchAgents</code> (Citation: AppleDocs Launch Agent Daemons) (Citation: OSX Keydnap malware) (Citation: Antiquated Mac Malware). These launch agents have property list files which point to the executables that will be launched (Citation: OSX.Dok Malware).</p>
<p>Adversaries may install a new launch agent that can be configured to execute at login by using launchd or launchctl to load a plist into the appropriate directories  (Citation: Sofacy Komplex Trojan)  (Citation: Methods of Mac Malware Persistence). The agent name may be disguised by using a name from a related operating system or benign software. Launch Agents are created with user level privileges and are executed with the privileges of the user when they log in (Citation: OSX Malware Detection) (Citation: OceanLotus for OS X). They can be set up to execute when a specific user logs in (in the specific user‚Äôs directory structure) or when any user logs in (which requires administrator privileges).
T1037.005 | Startup Items | Adversaries may use startup items automatically executed at boot initialization to establish persistence. Startup items execute during the final phase of the boot process and contain shell scripts or other executable files along with configuration information used by the system to determine the execution order for all startup items. (Citation: Startup Items)</p>
<p>This is technically a deprecated technology (superseded by <a class="reference external" href="https://attack.mitre.org/techniques/T1543/004">Launch Daemon</a>), and thus the appropriate folder, <code>/Library/StartupItems</code> isn‚Äôt guaranteed to exist on the system by default, but does appear to exist by default on macOS Sierra. A startup item is a directory whose executable and configuration property list (plist), <code>StartupParameters.plist</code>, reside in the top-level directory.</p>
<p>An adversary can create the appropriate folders/files in the StartupItems directory to register their own persistence mechanism (Citation: Methods of Mac Malware Persistence). Additionally, since StartupItems run during the bootup phase of macOS, they will run as the elevated root user.
T1037.004 | Rc.common | Adversaries may use rc.common automatically executed at boot initialization to establish persistence. During the boot process, macOS executes <code>source /etc/rc.common</code>, which is a shell script containing various utility functions. This file also defines routines for processing command-line arguments and for gathering system settings and is thus recommended to include in the start of Startup Item Scripts (Citation: Startup Items). In macOS and OS X, this is now a deprecated mechanism in favor of <a class="reference external" href="https://attack.mitre.org/techniques/T1543/001">Launch Agent</a> and <a class="reference external" href="https://attack.mitre.org/techniques/T1543/004">Launch Daemon</a> but is currently still used.</p>
<p>Adversaries can use the rc.common file as a way to hide code for persistence that will execute on each reboot as the root user. (Citation: Methods of Mac Malware Persistence)
T1055.012 | Process Hollowing | Adversaries may inject malicious code into suspended and hollowed processes in order to evade process-based defenses. Process hollowing is a method of executing arbitrary code in the address space of a separate live process.</p>
<p>Process hollowing is commonly performed by creating a process in a suspended state then unmapping/hollowing its memory, which can then be replaced with malicious code. A victim process can be created with native Windows API calls such as <code>CreateProcess</code>, which includes a flag to suspend the processes primary thread. At this point the process can be unmapped using APIs calls such as <code>ZwUnmapViewOfSection</code> or <code>NtUnmapViewOfSection</code>  before being written to, realigned to the injected code, and resumed via <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, <code>SetThreadContext</code>, then <code>ResumeThread</code> respectively.(Citation: Leitch Hollowing)(Citation: Endgame Process Injection July 2017)</p>
<p>This is very similar to <a class="reference external" href="https://attack.mitre.org/techniques/T1055/005">Thread Local Storage</a> but creates a new process rather than targeting an existing process. This behavior will likely not result in elevated privileges since the injected process was spawned from (and thus inherits the security context) of the injecting process. However, execution via process hollowing may also evade detection from security products since the execution is masked under a legitimate process.
T1055.013 | Process Doppelg√§nging | Adversaries may inject malicious code into process via process doppelg√§nging in order to evade process-based defenses as well as possibly elevate privileges. Process doppelg√§nging is a method of executing arbitrary code in the address space of a separate live process.</p>
<p>Windows Transactional NTFS (TxF) was introduced in Vista as a method to perform safe file operations. (Citation: Microsoft TxF) To ensure data integrity, TxF enables only one transacted handle to write to a file at a given time. Until the write handle transaction is terminated, all other handles are isolated from the writer and may only read the committed version of the file that existed at the time the handle was opened. (Citation: Microsoft Basic TxF Concepts) To avoid corruption, TxF performs an automatic rollback if the system or application fails during a write transaction. (Citation: Microsoft Where to use TxF)</p>
<p>Although deprecated, the TxF application programming interface (API) is still enabled as of Windows 10. (Citation: BlackHat Process Doppelg√§nging Dec 2017)</p>
<p>Adversaries may abuse TxF to a perform a file-less variation of <a class="reference external" href="https://attack.mitre.org/techniques/T1055">Process Injection</a>. Similar to <a class="reference external" href="https://attack.mitre.org/techniques/T1093">Process Hollowing</a>, process doppelg√§nging involves replacing the memory of a legitimate process, enabling the veiled execution of malicious code that may evade defenses and detection. Process doppelg√§nging‚Äôs use of TxF also avoids the use of highly-monitored API functions such as <code>NtUnmapViewOfSection</code>, <code>VirtualProtectEx</code>, and <code>SetThreadContext</code>. (Citation: BlackHat Process Doppelg√§nging Dec 2017)</p>
<p>Process Doppelg√§nging is implemented in 4 steps (Citation: BlackHat Process Doppelg√§nging Dec 2017):</p>
<ul class="simple">
<li><p>Transact ‚Äì Create a TxF transaction using a legitimate executable then overwrite the file with malicious code. These changes will be isolated and only visible within the context of the transaction.</p></li>
<li><p>Load ‚Äì Create a shared section of memory and load the malicious executable.</p></li>
<li><p>Rollback ‚Äì Undo changes to original executable, effectively removing malicious code from the file system.</p></li>
<li><p>Animate ‚Äì Create a process from the tainted section of memory and initiate execution.</p></li>
</ul>
<p>This behavior will likely not result in elevated privileges since the injected process was spawned from (and thus inherits the security context) of the injecting process. However, execution via process doppelg√§nging may evade detection from security products since the execution is masked under a legitimate process.
T1055.011 | Extra Window Memory Injection | Adversaries may inject malicious code into process via Extra Window Memory (EWM) in order to evade process-based defenses as well as possibly elevate privileges. EWM injection is a method of executing arbitrary code in the address space of a separate live process.</p>
<p>Before creating a window, graphical Windows-based processes must prescribe to or register a windows class, which stipulate appearance and behavior (via windows procedures, which are functions that handle input/output of data).(Citation: Microsoft Window Classes) Registration of new windows classes can include a request for up to 40 bytes of EWM to be appended to the allocated memory of each instance of that class. This EWM is intended to store data specific to that window and has specific application programming interface (API) functions to set and get its value. (Citation: Microsoft GetWindowLong function) (Citation: Microsoft SetWindowLong function)</p>
<p>Although small, the EWM is large enough to store a 32-bit pointer and is often used to point to a windows procedure. Malware may possibly utilize this memory location in part of an attack chain that includes writing code to shared sections of the process‚Äôs memory, placing a pointer to the code in EWM, then invoking execution by returning execution control to the address in the process‚Äôs EWM.</p>
<p>Execution granted through EWM injection may allow access to both the target process‚Äôs memory and possibly elevated privileges. Writing payloads to shared sections also avoids the use of highly monitored API calls such as <code>WriteProcessMemory</code> and <code>CreateRemoteThread</code>.(Citation: Endgame Process Injection July 2017) More sophisticated malware samples may also potentially bypass protection mechanisms such as data execution prevention (DEP) by triggering a combination of windows procedures and other system functions that will rewrite the malicious payload inside an executable portion of the target process.  (Citation: MalwareTech Power Loader Aug 2013) (Citation: WeLiveSecurity Gapz and Redyms Mar 2013)</p>
<p>Running code in the context of another process may allow access to the process‚Äôs memory, system/network resources, and possibly elevated privileges. Execution via EWM injection may also evade detection from security products since the execution is masked under a legitimate process.
T1055.014 | VDSO Hijacking | Adversaries may inject malicious code into processes via VDSO hijacking in order to evade process-based defenses as well as possibly elevate privileges. Virtual dynamic shared object (vdso) hijacking is a method of executing arbitrary code in the address space of a separate live process.</p>
<p>VDSO hijacking involves redirecting calls to dynamically linked shared libraries. Memory protections may prevent writing executable code to a process via <a class="reference external" href="https://attack.mitre.org/techniques/T1055/008">Ptrace System Calls</a>. However, an adversary may hijack the syscall interface code stubs mapped into a process from the vdso shared object to execute syscalls to open and map a malicious shared object. This code can then be invoked by redirecting the execution flow of the process via patched memory address references stored in a process‚Äô global offset table (which store absolute addresses of mapped library functions).(Citation: ELF Injection May 2009) (Citation: Backtrace VDSO) (Citation: VDSO Aug 2005) (Citation: Syscall 2014)</p>
<p>Running code in the context of another process may allow access to the process‚Äôs memory, system/network resources, and possibly elevated privileges. Execution via VDSO hijacking may also evade detection from security products since the execution is masked under a legitimate process.<br />
T1055.009 | Proc Memory | Adversaries may inject malicious code into processes via the /proc filesystem in order to evade process-based defenses as well as possibly elevate privileges. Proc memory injection is a method of executing arbitrary code in the address space of a separate live process.</p>
<p>Proc memory injection involves enumerating the memory of a process via the /proc filesystem (<code>/proc/[pid]</code>) then crafting a return-oriented programming (ROP) payload with available gadgets/instructions. Each running process has its own directory, which includes memory mappings. Proc memory injection is commonly performed by overwriting the target processes‚Äô stack using memory mappings provided by the /proc filesystem. This information can be used to enumerate offsets (including the stack) and gadgets (or instructions within the program that can be used to build a malicious payload) otherwise hidden by process memory protections such as address space layout randomization (ASLR). Once enumerated, the target processes‚Äô memory map within <code>/proc/[pid]/maps</code> can be overwritten using dd.(Citation: Uninformed Needle)(Citation: GDS Linux Injection)(Citation: DD Man)</p>
<p>Other techniques such as <a class="reference external" href="https://attack.mitre.org/techniques/T1574/006">LD_PRELOAD</a> may be used to populate a target process with more available gadgets. Similar to <a class="reference external" href="https://attack.mitre.org/techniques/T1055/012">Process Hollowing</a>, proc memory injection may target child processes (such as a backgrounded copy of sleep).(Citation: GDS Linux Injection)</p>
<p>Running code in the context of another process may allow access to the process‚Äôs memory, system/network resources, and possibly elevated privileges. Execution via proc memory injection may also evade detection from security products since the execution is masked under a legitimate process.
T1055.008 | Ptrace System Calls | Adversaries may inject malicious code into processes via ptrace (process trace) system calls in order to evade process-based defenses as well as possibly elevate privileges. Ptrace system call injection is a method of executing arbitrary code in the address space of a separate live process.</p>
<p>Ptrace system call injection involves attaching to and modifying a running process. The ptrace system call enables a debugging process to observe and control another process (and each individual thread), including changing memory and register values.(Citation: PTRACE man) Ptrace system call injection is commonly performed by writing arbitrary code into a running process (ex: <code>malloc</code>) then invoking that memory with <code>PTRACE_SETREGS</code> to set the register containing the next instruction to execute. Ptrace system call injection can also be done with <code>PTRACE_POKETEXT</code>/<code>PTRACE_POKEDATA</code>, which copy data to a specific address in the target processes‚Äô memory (ex: the current address of the next instruction). (Citation: PTRACE man)(Citation: Medium Ptrace JUL 2018)</p>
<p>Ptrace system call injection may not be possible targeting processes with high-privileges, and on some system those that are non-child processes.(Citation: BH Linux Inject)</p>
<p>Running code in the context of another process may allow access to the process‚Äôs memory, system/network resources, and possibly elevated privileges. Execution via ptrace system call injection may also evade detection from security products since the execution is masked under a legitimate process.
T1055.005 | Thread Local Storage | Adversaries may inject malicious code into processes via thread local storage (TLS) callbacks in order to evade process-based defenses as well as possibly elevate privileges. TLS callback injection is a method of executing arbitrary code in the address space of a separate live process.</p>
<p>TLS callback injection involves manipulating pointers inside a portable executable (PE) to redirect a process to malicious code before reaching the code‚Äôs legitimate entry point. TLS callbacks are normally used by the OS to setup and/or cleanup data used by threads. Manipulating TLS callbacks may be performed by allocating and writing to specific offsets within a process‚Äô memory space using other <a class="reference external" href="https://attack.mitre.org/techniques/T1055">Process Injection</a> techniques such as <a class="reference external" href="https://attack.mitre.org/techniques/T1055/012">Process Hollowing</a>.(Citation: FireEye TLS Nov 2017)</p>
<p>Running code in the context of another process may allow access to the process‚Äôs memory, system/network resources, and possibly elevated privileges. Execution via TLS callback injection may also evade detection from security products since the execution is masked under a legitimate process.
T1055.004 | Asynchronous Procedure Call | Adversaries may inject malicious code into processes via the asynchronous procedure call (APC) queue in order to evade process-based defenses as well as possibly elevate privileges. APC injection is a method of executing arbitrary code in the address space of a separate live process.</p>
<p>APC injection is commonly performed by attaching malicious code to the APC Queue (Citation: Microsoft APC) of a process‚Äôs thread. Queued APC functions are executed when the thread enters an alterable state.(Citation: Microsoft APC) A handle to an existing victim process is first created with native Windows API calls such as <code>OpenThread</code>. At this point <code>QueueUserAPC</code> can be used to invoke a function (such as <code>LoadLibrayA</code> pointing to a malicious DLL).</p>
<p>A variation of APC injection, dubbed ‚ÄúEarly Bird injection‚Äù, involves creating a suspended process in which malicious code can be written and executed before the process‚Äô entry point (and potentially subsequent anti-malware hooks) via an APC. (Citation: CyberBit Early Bird Apr 2018) AtomBombing (Citation: ENSIL AtomBombing Oct 2016) is another variation that utilizes APCs to invoke malicious code previously written to the global atom table.(Citation: Microsoft Atom Table)</p>
<p>Running code in the context of another process may allow access to the process‚Äôs memory, system/network resources, and possibly elevated privileges. Execution via APC injection may also evade detection from security products since the execution is masked under a legitimate process.
T1055.003 | Thread Execution Hijacking | Adversaries may inject malicious code into hijacked processes in order to evade process-based defenses as well as possibly elevate privileges. Thread Execution Hijacking is a method of executing arbitrary code in the address space of a separate live process.</p>
<p>Thread Execution Hijacking is commonly performed by suspending an existing process then unmapping/hollowing its memory, which can then be replaced with malicious code or the path to a DLL. A handle to an existing victim process is first created with native Windows API calls such as <code>OpenThread</code>. At this point the process can be suspended then written to, realigned to the injected code, and resumed via <code>SuspendThread </code>, <code>VirtualAllocEx</code>, <code>WriteProcessMemory</code>, <code>SetThreadContext</code>, then <code>ResumeThread</code> respectively.(Citation: Endgame Process Injection July 2017)</p>
<p>This is very similar to <a class="reference external" href="https://attack.mitre.org/techniques/T1055/012">Process Hollowing</a> but targets an existing process rather than creating a process in a suspended state.</p>
<p>Running code in the context of another process may allow access to the process‚Äôs memory, system/network resources, and possibly elevated privileges. Execution via Thread Execution Hijacking may also evade detection from security products since the execution is masked under a legitimate process.
T1055.002 | Portable Executable Injection | Adversaries may inject portable executables (PE) into processes in order to evade process-based defenses as well as possibly elevate privileges. PE injection is a method of executing arbitrary code in the address space of a separate live process.</p>
<p>PE injection is commonly performed by copying code (perhaps without a file on disk) into the virtual address space of the target process before invoking it via a new thread. The write can be performed with native Windows API calls such as <code>VirtualAllocEx</code> and <code>WriteProcessMemory</code>, then invoked with <code>CreateRemoteThread</code> or additional code (ex: shellcode). The displacement of the injected code does introduce the additional requirement for functionality to remap memory references. (Citation: Endgame Process Injection July 2017)</p>
<p>Running code in the context of another process may allow access to the process‚Äôs memory, system/network resources, and possibly elevated privileges. Execution via PE injection may also evade detection from security products since the execution is masked under a legitimate process.
T1055.001 | Dynamic-link Library Injection | Adversaries may inject dynamic-link libraries (DLLs) into processes in order to evade process-based defenses as well as possibly elevate privileges. DLL injection is a method of executing arbitrary code in the address space of a separate live process.</p>
<p>DLL injection is commonly performed by writing the path to a DLL in the virtual address space of the target process before loading the DLL by invoking a new thread. The write can be performed with native Windows API calls such as <code>VirtualAllocEx</code> and <code>WriteProcessMemory</code>, then invoked with <code>CreateRemoteThread</code> (which calls the <code>LoadLibrary</code> API responsible for loading the DLL). (Citation: Endgame Process Injection July 2017)</p>
<p>Variations of this method such as reflective DLL injection (writing a self-mapping DLL into a process) and memory module (map DLL when writing into process) overcome the address relocation issue as well as the additional APIs to invoke execution (since these methods load and execute the files in memory by manually preforming the function of <code>LoadLibrary</code>).(Citation: Endgame HuntingNMemory June 2017)(Citation: Endgame Process Injection July 2017)</p>
<p>Running code in the context of another process may allow access to the process‚Äôs memory, system/network resources, and possibly elevated privileges. Execution via DLL injection may also evade detection from security products since the execution is masked under a legitimate process.
T1037.003 | Network Logon Script | Adversaries may use network logon scripts automatically executed at logon initialization to establish persistence. Network logon scripts can be assigned using Active Directory or Group Policy Objects.(Citation: Petri Logon Script AD) These logon scripts run with the privileges of the user they are assigned to. Depending on the systems within the network, initializing one of these scripts could apply to more than one or potentially all systems.</p>
<p>Adversaries may use these scripts to maintain persistence on a network. Depending on the access configuration of the logon scripts, either local credentials or an administrator account may be necessary.
T1543 | Create or Modify System Process | Adversaries may create or modify system-level processes to repeatedly execute malicious payloads as part of persistence. When operating systems boot up, they can start processes that perform background system functions. On Windows and Linux, these system processes are referred to as services. (Citation: TechNet Services) On macOS, launchd processes known as <a class="reference external" href="https://attack.mitre.org/techniques/T1543/004">Launch Daemon</a> and <a class="reference external" href="https://attack.mitre.org/techniques/T1543/001">Launch Agent</a> are run to finish system initialization and load user specific parameters.(Citation: AppleDocs Launch Agent Daemons)</p>
<p>Adversaries may install new services, daemons, or agents that can be configured to execute at startup or a repeatable interval in order to establish persistence. Similarly, adversaries may modify existing services, daemons, or agents to achieve the same effect.</p>
<p>Services, daemons, or agents may be created with administrator privileges but executed under root/SYSTEM privileges. Adversaries may leverage this functionality to create or modify system processes in order to escalate privileges. (Citation: OSX Malware Detection).<br />
T1037.002 | Logon Script (Mac) | Adversaries may use macOS logon scripts automatically executed at logon initialization to establish persistence. macOS allows logon scripts (known as login hooks) to be executed whenever a specific user logs into a system. A login hook tells Mac OS X to execute a certain script when a user logs in, but unlike <a class="reference external" href="https://attack.mitre.org/techniques/T1037/005">Startup Items</a>, a login hook executes as the elevated root user.(Citation: creating login hook)</p>
<p>Adversaries may use these login hooks to maintain persistence on a single system.(Citation: S1 macOs Persistence) Access to login hook scripts may allow an adversary to insert additional malicious code. There can only be one login hook at a time though and depending on the access configuration of the hooks, either local credentials or an administrator account may be necessary.
T1037.001 | Logon Script (Windows) | Adversaries may use Windows logon scripts automatically executed at logon initialization to establish persistence. Windows allows logon scripts to be run whenever a specific user or group of users log into a system.(Citation: TechNet Logon Scripts) This is done via adding a path to a script to the <code>HKCU\Environment\UserInitMprLogonScript</code> Registry key.(Citation: Hexacorn Logon Scripts)</p>
<p>Adversaries may use these scripts to maintain persistence on a single system. Depending on the access configuration of the logon scripts, either local credentials or an administrator account may be necessary.
T1053.003 | Cron | Adversaries may abuse the <code>cron</code> utility to perform task scheduling for initial or recurring execution of malicious code. The <code>cron</code> utility is a time-based job scheduler for Unix-like operating systems.  The <code> crontab</code> file contains the schedule of cron entries to be run and the specified times for execution. Any <code>crontab</code> files are stored in operating system-specific file paths.</p>
<p>An adversary may use <code>cron</code> in Linux or Unix environments to execute programs at system startup or on a scheduled basis for persistence. <code>cron</code> can also be abused to conduct remote Execution as part of Lateral Movement and or to run a process under the context of a specified account.
T1053.004 | Launchd | Adversaries may abuse the <code>Launchd</code> daemon to perform task scheduling for initial or recurring execution of malicious code. The <code>launchd</code> daemon, native to macOS, is responsible for loading and maintaining services within the operating system. This process loads the parameters for each launch-on-demand system-level daemon from the property list (plist) files found in <code>/System/Library/LaunchDaemons</code> and <code>/Library/LaunchDaemons</code> (Citation: AppleDocs Launch Agent Daemons). These LaunchDaemons have property list files which point to the executables that will be launched (Citation: Methods of Mac Malware Persistence).</p>
<p>An adversary may use the <code>launchd</code> daemon in macOS environments to schedule new executables to run at system startup or on a scheduled basis for persistence. <code>launchd</code> can also be abused to run a process under the context of a specified account. Daemons, such as <code>launchd</code>, run with the permissions of the root user account, and will operate regardless of which user account is logged in.
T1053.001 | At (Linux) | Adversaries may abuse the <a class="reference external" href="https://attack.mitre.org/software/S0110">at</a> utility to perform task scheduling for initial or recurring execution of malicious code. The <a class="reference external" href="https://attack.mitre.org/software/S0110">at</a> command within Linux operating systems enables administrators to schedule tasks.(Citation: Kifarunix - Task Scheduling in Linux)</p>
<p>An adversary may use <a class="reference external" href="https://attack.mitre.org/software/S0110">at</a> in Linux environments to execute programs at system startup or on a scheduled basis for persistence. <a class="reference external" href="https://attack.mitre.org/software/S0110">at</a> can also be abused to conduct remote Execution as part of Lateral Movement and or to run a process under the context of a specified account.
T1053.005 | Scheduled Task | Adversaries may abuse the Windows Task Scheduler to perform task scheduling for initial or recurring execution of malicious code. There are multiple ways to access the Task Scheduler in Windows. The <code>schtasks</code> can be run directly on the command line, or the Task Scheduler can be opened through the GUI within the Administrator Tools section of the Control Panel. In some cases, adversaries have used a .NET wrapper for the Windows Task Scheduler, and alternatively, adversaries have used the Windows netapi32 library to create a scheduled task.</p>
<p>The deprecated <a class="reference external" href="https://attack.mitre.org/software/S0110">at</a> utility could also be abused by adversaries (ex: <a class="reference external" href="https://attack.mitre.org/techniques/T1053/002">At (Windows)</a>), though <code>at.exe</code> can not access tasks created with <code>schtasks</code> or the Control Panel.</p>
<p>An adversary may use Windows Task Scheduler to execute programs at system startup or on a scheduled basis for persistence. The Windows Task Scheduler can also be abused to conduct remote Execution as part of Lateral Movement and or to run a process under the context of a specified account (such as SYSTEM).
T1053.002 | At (Windows) | Adversaries may abuse the <code>at.exe</code> utility to perform task scheduling for initial or recurring execution of malicious code. The <a class="reference external" href="https://attack.mitre.org/software/S0110">at</a> utility exists as an executable within Windows for scheduling tasks at a specified time and date. Using <a class="reference external" href="https://attack.mitre.org/software/S0110">at</a> requires that the Task Scheduler service be running, and the user to be logged on as a member of the local Administrators group.</p>
<p>An adversary may use <code>at.exe</code> in Windows environments to execute programs at system startup or on a scheduled basis for persistence. <a class="reference external" href="https://attack.mitre.org/software/S0110">at</a> can also be abused to conduct remote Execution as part of Lateral Movement and or to run a process under the context of a specified account (such as SYSTEM).</p>
<p>Note: The <code>at.exe</code> command line utility has been deprecated in current versions of Windows in favor of <code>schtasks</code>.
T1484 | Group Policy Modification | Adversaries may modify Group Policy Objects (GPOs) to subvert the intended discretionary access controls for a domain, usually with the intention of escalating privileges on the domain. Group policy allows for centralized management of user and computer settings in Active Directory (AD). GPOs are containers for group policy settings made up of files stored within a predicable network path <code>\&lt;DOMAIN&gt;\SYSVOL&amp;lt;DOMAIN&gt;\Policies&lt;/code&gt;.(Citation: TechNet Group Policy Basics)(Citation: ADSecurity GPO Persistence 2016)</p>
<p>Like other objects in AD, GPOs have access controls associated with them. By default all user accounts in the domain have permission to read GPOs. It is possible to delegate GPO access control permissions, e.g. write access, to specific users or groups in the domain.</p>
<p>Malicious GPO modifications can be used to implement many other malicious behaviors such as <a class="reference external" href="https://attack.mitre.org/techniques/T1053">Scheduled Task/Job</a>, <a class="reference external" href="https://attack.mitre.org/techniques/T1562/001">Disable or Modify Tools</a>, <a class="reference external" href="https://attack.mitre.org/techniques/T1105">Ingress Tool Transfer</a>, <a class="reference external" href="https://attack.mitre.org/techniques/T1136">Create Account</a>, <a class="reference external" href="https://attack.mitre.org/techniques/T1035">Service Execution</a>,  and more.(Citation: ADSecurity GPO Persistence 2016)(Citation: Wald0 Guide to GPOs)(Citation: Harmj0y Abusing GPO Permissions)(Citation: Mandiant M Trends 2016)(Citation: Microsoft Hacking Team Breach) Since GPOs can control so many user and machine settings in the AD environment, there are a great number of potential attacks that can stem from this GPO abuse.(Citation: Wald0 Guide to GPOs)</p>
<p>For example, publicly available scripts such as <code>New-GPOImmediateTask</code> can be leveraged to automate the creation of a malicious <a class="reference external" href="https://attack.mitre.org/techniques/T1053">Scheduled Task/Job</a> by modifying GPO settings, in this case modifying <code>&lt;GPO_PATH&gt;\Machine\Preferences\ScheduledTasks\ScheduledTasks.xml</code>.(Citation: Wald0 Guide to GPOs)(Citation: Harmj0y Abusing GPO Permissions) In some cases an adversary might modify specific user rights like SeEnableDelegationPrivilege, set in <code>&lt;GPO_PATH&gt;\MACHINE\Microsoft\Windows NT\SecEdit\GptTmpl.inf</code>, to achieve a subtle AD backdoor with complete control of the domain because the user account under the adversary‚Äôs control would then be able to modify GPOs.(Citation: Harmj0y SeEnableDelegationPrivilege Right)</p>
<p>T1134 | Access Token Manipulation | Adversaries may modify access tokens to operate under a different user or system security context to perform actions and bypass access controls. Windows uses access tokens to determine the ownership of a running process. A user can manipulate access tokens to make a running process appear as though it is the child of a different process or belongs to someone other than the user that started the process. When this occurs, the process also takes on the security context associated with the new token.</p>
<p>An adversary can use built-in Windows API functions to copy access tokens from existing processes; this is known as token stealing. These token can then be applied to an existing process (i.e. <a class="reference external" href="https://attack.mitre.org/techniques/T1134/001">Token Impersonation/Theft</a>) or used to spawn a new process (i.e. <a class="reference external" href="https://attack.mitre.org/techniques/T1134/002">Create Process with Token</a>). An adversary must already be in a privileged user context (i.e. administrator) to steal a token. However, adversaries commonly use token stealing to elevate their security context from the administrator level to the SYSTEM level. An adversary can then use a token to authenticate to a remote system as the account for that token if the account has appropriate permissions on the remote system.(Citation: Pentestlab Token Manipulation)</p>
<p>Any standard user can use the <code>runas</code> command, and the Windows API functions, to create impersonation tokens; it does not require access to an administrator account. There are also other mechanisms, such as Active Directory fields, that can be used to modify access tokens.
T1078 | Valid Accounts | Adversaries may obtain and abuse credentials of existing accounts as a means of gaining Initial Access, Persistence, Privilege Escalation, or Defense Evasion. Compromised credentials may be used to bypass access controls placed on various resources on systems within the network and may even be used for persistent access to remote systems and externally available services, such as VPNs, Outlook Web Access and remote desktop. Compromised credentials may also grant an adversary increased privilege to specific systems or access to restricted areas of the network. Adversaries may choose not to use malware or tools in conjunction with the legitimate access those credentials provide to make it harder to detect their presence.</p>
<p>The overlap of permissions for local, domain, and cloud accounts across a network of systems is of concern because the adversary may be able to pivot across accounts and systems to reach a high level of access (i.e., domain or enterprise administrator) to bypass access controls set within the enterprise. (Citation: TechNet Credential Theft)
T1068 | Exploitation for Privilege Escalation | Adversaries may exploit software vulnerabilities in an attempt to collect elevate privileges. Exploitation of a software vulnerability occurs when an adversary takes advantage of a programming error in a program, service, or within the operating system software or kernel itself to execute adversary-controlled code. Security constructs such as permission levels will often hinder access to information and use of certain techniques, so adversaries will likely need to perform privilege escalation to include use of software exploitation to circumvent those restrictions.</p>
<p>When initially gaining access to a system, an adversary may be operating within a lower privileged process which will prevent them from accessing certain resources on the system. Vulnerabilities may exist, usually in operating system components and software commonly running at higher permissions, that can be exploited to gain higher levels of access on the system. This could enable someone to move from unprivileged or user level permissions to SYSTEM or root permissions depending on the component that is vulnerable. This may be a necessary step for an adversary compromising a endpoint system that has been properly configured and limits other privilege escalation methods.
T1055 | Process Injection | Adversaries may inject code into processes in order to evade process-based defenses as well as possibly elevate privileges. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process‚Äôs memory, system/network resources, and possibly elevated privileges. Execution via process injection may also evade detection from security products since the execution is masked under a legitimate process.</p>
<p>There are many different ways to inject code into a process, many of which abuse legitimate functionalities. These implementations exist for every major OS but are typically platform specific.</p>
<p>More sophisticated samples may perform multiple process injections to segment modules and further evade detection, utilizing named pipes or other inter-process communication (IPC) mechanisms as a communication channel.
T1053 | Scheduled Task/Job | Adversaries may abuse task scheduling functionality to facilitate initial or recurring execution of malicious code. Utilities exist within all major operating systems to schedule programs or scripts to be executed at a specified date and time. A task can also be scheduled on a remote system, provided the proper authentication is met (ex: RPC and file and printer sharing in Windows environments). Scheduling a task on a remote system typically requires being a member of an admin or otherwise privileged group on the remote system.(Citation: TechNet Task Scheduler Security)</p>
<p>Adversaries may use task scheduling to execute programs at system startup or on a scheduled basis for persistence. These mechanisms can also be abused to run a process under the context of a specified account (such as one with elevated permissions/privileges).
T1037 | Boot or Logon Initialization Scripts | Adversaries may use scripts automatically executed at boot or logon initialization to establish persistence. Initialization scripts can be used to perform administrative functions, which may often execute other programs or send information to an internal logging server. These scripts can vary based on operating system and whether applied locally or remotely.</p>
<p>Adversaries may use these scripts to maintain persistence on a single system. Depending on the access configuration of the logon scripts, either local credentials or an administrator account may be necessary.</p>
<p>An adversary may also be able to escalate their privileges since some boot or logon initialization scripts run with higher privileges.
T1034 | Path Interception | <strong>This technique has been deprecated. Please use <a class="reference external" href="https://attack.mitre.org/techniques/T1574/007">Path Interception by PATH Environment Variable</a>, <a class="reference external" href="https://attack.mitre.org/techniques/T1574/008">Path Interception by Search Order Hijacking</a>, and/or <a class="reference external" href="https://attack.mitre.org/techniques/T1574/009">Path Interception by Unquoted Path</a>.</strong></p>
<p>Path interception occurs when an executable is placed in a specific path so that it is executed by an application instead of the intended target. One example of this was the use of a copy of <a class="reference external" href="https://attack.mitre.org/software/S0106">cmd</a> in the current working directory of a vulnerable application that loads a CMD or BAT file with the CreateProcess function. (Citation: TechNet MS14-019)</p>
<p>There are multiple distinct weaknesses or misconfigurations that adversaries may take advantage of when performing path interception: unquoted paths, path environment variable misconfigurations, and search order hijacking. The first vulnerability deals with full program paths, while the second and third occur when program paths are not specified. These techniques can be used for persistence if executables are called on a regular basis, as well as privilege escalation if intercepted executables are started by a higher privileged process.</p>
<div class="section" id="unquoted-paths">
<h3>Unquoted Paths<a class="headerlink" href="#unquoted-paths" title="Permalink to this headline">¬∂</a></h3>
<p>Service paths (stored in Windows Registry keys) (Citation: Microsoft Subkey) and shortcut paths are vulnerable to path interception if the path has one or more spaces and is not surrounded by quotation marks (e.g., <code>C:\unsafe path with space\program.exe</code> vs. <code>‚ÄùC:\safe path with space\program.exe‚Äù</code>). (Citation: Baggett 2012) An adversary can place an executable in a higher level directory of the path, and Windows will resolve that executable instead of the intended executable. For example, if the path in a shortcut is <code>C:\program files\myapp.exe</code>, an adversary may create a program at <code>C:\program.exe</code> that will be run instead of the intended program. (Citation: SecurityBoulevard Unquoted Services APR 2018) (Citation: SploitSpren Windows Priv Jan 2018)</p>
</div>
<div class="section" id="path-environment-variable-misconfiguration">
<h3>PATH Environment Variable Misconfiguration<a class="headerlink" href="#path-environment-variable-misconfiguration" title="Permalink to this headline">¬∂</a></h3>
<p>The PATH environment variable contains a list of directories. Certain methods of executing a program (namely using cmd.exe or the command-line) rely solely on the PATH environment variable to determine the locations that are searched for a program when the path for the program is not given. If any directories are listed in the PATH environment variable before the Windows directory, <code>%SystemRoot%\system32</code> (e.g., <code>C:\Windows\system32</code>), a program may be placed in the preceding directory that is named the same as a Windows program (such as cmd, PowerShell, or Python), which will be executed when that command is executed from a script or command-line.</p>
<p>For example, if <code>C:\example path</code> precedes <code>C:\Windows\system32</code> is in the PATH environment variable, a program that is named net.exe and placed in <code>C:\example path</code> will be called instead of the Windows system ‚Äúnet‚Äù when ‚Äúnet‚Äù is executed from the command-line.</p>
</div>
<div class="section" id="search-order-hijacking">
<h3>Search Order Hijacking<a class="headerlink" href="#search-order-hijacking" title="Permalink to this headline">¬∂</a></h3>
<p>Search order hijacking occurs when an adversary abuses the order in which Windows searches for programs that are not given a path. The search order differs depending on the method that is used to execute the program. (Citation: Microsoft CreateProcess) (Citation: Hill NT Shell) (Citation: Microsoft WinExec) However, it is common for Windows to search in the directory of the initiating program before searching through the Windows system directory. An adversary who finds a program vulnerable to search order hijacking (i.e., a program that does not specify the path to an executable) may take advantage of this vulnerability by creating a program named after the improperly specified program and placing it within the initiating program‚Äôs directory.</p>
<p>For example, ‚Äúexample.exe‚Äù runs ‚Äúcmd.exe‚Äù with the command-line argument <code>net user</code>. An adversary may place a program called ‚Äúnet.exe‚Äù within the same directory as example.exe, ‚Äúnet.exe‚Äù will be run instead of the Windows system utility net. In addition, if an adversary places a program called ‚Äúnet.com‚Äù in the same directory as ‚Äúnet.exe‚Äù, then <code>cmd.exe /C net user</code> will execute ‚Äúnet.com‚Äù instead of ‚Äúnet.exe‚Äù due to the order of executable extensions defined under PATHEXT. (Citation: MSDN Environment Property)</p>
<p>Search order hijacking is also a common practice for hijacking DLL loads and is covered in <a class="reference external" href="https://attack.mitre.org/techniques/T1038">DLL Search Order Hijacking</a>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#Invoke-AtomicTest-By can be downloaded from https://github.com/haresudhan/ART-Utils/Invoke-AtomicTest-By</span>
<span class="n">Invoke</span><span class="o">-</span><span class="n">AtomicTest</span><span class="o">-</span><span class="n">By</span> <span class="o">-</span><span class="n">Tactic</span> <span class="n">privilege</span><span class="o">-</span><span class="n">escalation</span>
</pre></div>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
</div>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: ".net-powershell"
        },
        kernelOptions: {
            kernelName: ".net-powershell",
            path: "./tactics"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = '.net-powershell'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="persistence/T1053.003.html" title="previous page">T1053.003 - Scheduled Task/Job: Cron</a>
    <a class='right-next' id="next-link" href="privilege-escalation/T1548.002.html" title="next page">T1548.002 - Abuse Elevation Control Mechanism: Bypass User Access Control</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Hare Sudhan Muthusamy<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    <script src="../_static/js/index.js"></script>
    
  </body>
</html>